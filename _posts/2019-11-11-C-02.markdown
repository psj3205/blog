---
layout: post
title:  "C언어 본색 정리"
date:   2019-11-11 11:45:02 +0900
---

# 2. C언어의 기본 구조와 표준 입출력
## 2.1 C언어의 기본 구조
  ```c
  #include <stdio.h>

  int main(void){
    printf("Hello C world \n");
    return 0;
  }
  ```
  - 전처리기(Proprocessor)
    - 컴파일러가 컴파일을 수행하기 전에 **먼저** 처리한다.
  - 헤더 파일
    - 확장자 H를 갖는 파일
    - **표준 라이브러리 함수들의 동작을 정의해 놓은 파일**
  - main() 함수
    - 프로그램이 실행될 때 **가장 먼저** 호출되고 **가장 나중에** 종료되는 함수
    - 운영체제가 호출
      - 소스 파일을 컴파일하고 링크해서 만든 실행파일을 실행하면 운영체제가 실행파일 내의 main()함수를 가장 먼저 호출하기로 약속되어 있음
    - C언어로 작성된 프로그램은 **main()함수를 반드시 가지고 있음**
    - 함수의 기능은 **중괄호 안**에 작성한다.
    - 세미콜론은 연산을 수행하는 **문장이 끝남을 의미**
    - return은 **반환**과 **종료**의 의미를 가짐
      - 함수를 호출한 영역으로 값을 반환
      - main()함수를 종료

## 2.2 printf() 함수
  ```c
  #include <stdio.h>
  int main(void){
    printf("%d 더하기 %d는 %d입니다. \n", 3, 5, 3 + 5);
    printf("%i 더하기 %i는 %i입니다. \n", 3, 5, 3 + 5);
  }
  ```
  - printf() 함수는 숫자들의 계산, 10진수 정수, 8진수 정수, 16진수 정수, 실수, 문자, 문자열 등을 출력

    서식문자|출력형태
    -------|--------
    %d, %i|10진수 정수(양수, 음수 모두 가능)
    %x, %o|16진수 정수, 8진수 정수(양수만 가능)
    %f, %lf|10진수 실수(양수, 음수 모두 가능)
    %c|한 개의 문자
    %s|문자열
    %u|10진수 정수(양수만 가능) %d의 두배 범위
    %e, %E|e표기법, E표기법에 의한 실수
    %g, %G|소수점 이하 자리수에 따라 %f, %e 둘중 선택
    %%|% 기호 출력

## 2.3 scanf() 함수
  - 표준입력 : 키보드로부터 데이터를 입력받는 것
  - 표준출력 : 데이터를 모니터로 출력하는 것
  - scanf()함수는 키보드로 데이터를 입력받을 수 있는 함수
  ```c
  #include <stdio.h>

  int main(void){
    int age;
    scanf("%d", &age);
    printf("your age is %d", age);
    return 0;
  }
  ```
---

# 3. 변수란 무엇인가?
## 3.1 변수 선언하기
  - 변수 : 데이터를 저장하는 **메모리 공간**
  - 데이터를 저장하기 위해서는 반드시 **변수(메모리 공간)이 필요**
  - 변수의 형태
    - 정수형 변수 : char형, short형, int형, long형
    - 실수형 변수 : float형, double형, long double형
  - 변수는 언제든지 **다른 데이터로 변경**될 수 있다.

## 3.2 변수 선언 시 주의 점
  - C언어에서 변수를 선언할 경우, 함수의 맨 처음에서 해야 한다.
  - 특수기호, 공백문자, 변수 이름 맨 처음에 숫자를 사용하면 안됨
  - C언어는 **대소문자를 구분**

## 3.3 변수의 시작 주소와 & 연산자
  - 특정 변수가 메모리 공간의 어디에 있는지를 가리키는 것을 **변수의 시작 주소**라고 한다.
  - C언어에서는 **&연산자**를 사용하면 변수의 시작 주소를 알 수 있음

  ```c
  #include <stdio.h>

  int main(void) {
    int a = 3;
    int b = 4;

    printf("a의 값 : %d \n", a);
    printf("b의 값 : %d \n", b);

    printf("변수 a의 시작 주소 : %x \n", &a);
    printf("변수 b의 시작 주소 : %x \n", &b);
    
    return 0;
  }
  ```

---
# 4. 상수란 무엇인가?
## 4.1 상수란?
  - 상수 : 프로그램 실행 도중 **값이 변경되지 않는 데이터**
  - 상수의 형태
    - 리터럴 상수 : 글자 그대로 의미가 있어서 이름이 없는 상수
      - 정수형 상수, 실수형 상수, 문자 상수, 문자열 상수
    - 심볼릭 상수 : 상수를 기호화하여 변수처럼 이름을 지어 쓰는 상수
      - 변수를 상수화하는 것

## 4.2 리터럴 상수
  ```c
  #include <stdio.h>
  
  int main(void){
    printf("10진수 정수형 상수 %d + %d = %d \n", 10, 20, 10 + 20);
    printf("16진수 정수형 상수 %x + %x = %x \n", 0x10, 0x20, 0x10 + 0x20);
    printf("8진수 정수형 상수 %o + %o = %o \n", 010, 020, 010 + 020);

    return 0;
  }
  ```
  - 정수형 상수 : 소수점이 포함되지 않은 상수

  ```c
  #include <stdio.h>

  int main(void){
    printf("실수형 상수 %lf + %lf = %lf입니다. \n", 3.1, 4.1, 3.1+ 4.1);

    return 0;
  }
  ```
  - 실수형 상수 : 소수점이 포함된 상수
  - 문자 상수 : **작은따옴표**로 묶은 문자 한개
  - 문자열 상수 : **큰따옴표**로 묶은 문자열
    - 컴파일러는 큰따옴표로 묶은 문자열 상수를 저장할 때 문자열 상수 끝에 문자열의 끝을 알리는 종료문자 **\0**을 자동으로 추가하는데 이것을 **NULL문자**라고 함
  
## 4.3 심볼릭 상수
  - 심볼릭 상수를 만드는 방법
    ```c
    #include <stdio.h>
    
    #define PI 3.14

    int main(void){
      const int NUM = 100;

      return 0;
    }
    ```
    - `const` 키워드 사용
    - `#define` 문 사용
    - 심볼릭 상수는 반드시 선언과 초기화를 동시에 해야한다.
    - #define 문은 전처리기에서 수행되는 문장으로 소스를 컴파일하기 전에 먼저 수행

---
# 5. 연산자란 무엇인가?
## 5.1 연산자의 종류
  - 연산자(Operator) : **연산을 수행하는 기호**를 의미
  - 피연산자(Operand) : 연산에 참여하는 변수나 상수 값
    분류|연산자
    ----|-----
    대입연산자|=
    산술연산자|+, -, *, /, %
    복합대입연산자|+=, -=, *=, /=, %=
    증감연산자|++, --
    관계연산자|>, <, ==, !=, >=, <=
    논리연산자|&&, \|\|\, !
    조건연산자|? :
    비트논리연산자|&, \|\, ^, ~ 
    비트이동연산자|>>, <<
  - C언어의 관계연산자는 **참/거짓**을 숫자로 표현
    - 거짓: 0(10진수 0)으로 표현
    - 참: 1(10진수 1)으로 표현
    - **0이외의 모든 숫자는 참으로 인식**

## 5.2 비트 연산자
  - 컴퓨터는 모든 정보를 **1과 0으로 이루어진 이진값**으로 저장하고 처리
  - 비트(Bit) : 2진수 값 하나를 저장할 수 있는 최소 메모리 공간
  - 바이트(Byte) : 8개의 연속된 비트, 총 256(2^8)가지의 경우를 표현
  - 16진수는 2진수 네자리, 8진수는 2진수 세자리를 각각 한자리 숫자로 표현 가능
  - 왼쪽 시프트 연산자
    ```c
    #include <stdio.h>
    int main(void){
      int num1 = 10;

      int result1 = num1 << 1;

      printf("비트 단위 >> 연산의 결과 %d \n", result1);

      return 0;
    }
    ```
    - 왼쪽 시프트 연산자인 경우 빈공간을 무조건 0으로 채움
    - 어떤 값을 왼쪽으로 1비트 씩 이동시킬 때마다 **2가 곱해진다.**
  - 오른쪽 시프트 연산자
    ```c
    #include <stdio.h>
    int main(void){
      int num1 = 10;
      int num2 = -10;

      int result1 = num1 >> 1;
      int result2 = num2 >> 1;

      printf("비트 단위 >> 연산의 결과 %d \n", result1);
      printf("비트 단위 >> 연산의 결과 %d \n", result2);

      return 0;
    }
    ```
    - 변수가 양수이면 빈 공간을 0으로 채움
    - 변수가 음수이면 빈 공간을 1로 채움
    - 어떤 값을 오른쪽으로 1비트 씩 이동시킬 때마다 **2가 나누어진다.**
    - 5장 연습문제 7번 풀이
    ```c
    #include <stdio.h>
    #include <math.h>
    int main(void) {
      int x;
      int i;
      int result = 0;
      scanf_s("%d", &x);
      
      for (i = 0; i < 32; i++) {
        result += x % 10 ? pow(2, i) : 0;
        x /= 10;
      }
      printf("%d \n", result);

      return 0;
    }
    ```
---

# 6. 자료형이란 무엇인가?
## 6.1 자료형이란
  - 변수가 저장하는 **데이터의 형식(Data Type)**
  - 변수 선언 시, 자료형과 변수 이름을 **공백으로 구분**
  - 자료형에 해당하는 크기의 메모리가 할당
  - 자료형의 종류
    - 정수형(char, short, int, long)
    - 실수형(float, double, long double)
  - 자료형마다 **메모리 공간의 크기**가 다르고, **서식문자**와 데이터 **표현 범위**가 다름
  - 기본 자료형의 메모리 크기
    - 정수형
      char|short|int|long
      --|--|--|--
      1바이트|2바이트|4바이트|4바이트
    - 실수형
      float|double|long double
      --|--|--
      4바이트|8바이트|8바이트
  
## 6.2 정수형
  - 정수형 자료형의 표현 범위
    정수형|메모리 크기|데이터 표현 범위
    --|--|--
    char|1바이트|-128 ~ +127
    short|2바이트|-32768 ~ +32767
    int|4바이트|-2147483648 ~ +2147483647
    long|4바이트|-2147483648 ~ +2147483647
  - `unsigned` 키워드는 정수형의 양수 표현 범위를 두배로 늘린다.
    - `signed` : 양수, 0, 음수를 모두 표현(보통 생략)
    - `unsigned` : 양수, 0만 표현
  - `unsigned`형을 출력할 때는 **%u**를 사용해야 한다.
  - **정수형**은 `int`형을 선호
    - 정수형 데이터를 저장하는 변수를 선언할 때는 주로 int형을 사용한다.
    - 정수형 자료형 중에 int형을 CPU가 가장 빠르게 처리하기 때문에
    - 현재 개발된 대부분의 컴퓨터는 32비트 이상의 시스템이기 때문에 CPU가 연산하는 기본 단위가 최소 32비트이다.
    - 따라서 정수 데이터를 char형 변수에 저장하여 덧셈을 할 경우 int형으로 바꿔서 연산한다.

## 6.3 실수형
  - 실수형 자료형의 표현 범위
    실수형|메모리 크기|데이터 표현 범위
    -|-|-
    float|4바이트|1.17 * 10<sup>-38</sup> ~ 3.40 * 10<sup>38</sup>
    double|8바이트|2.22 * 10<sup>-308</sup> ~ 1.79 * 10<sup>308</sup>
    long double|8바이트|2.22 * 10<sup>-308</sup> ~ 1.79 * 10<sup>308</sup>
  - 실수형은 데이터의 정밀도를 높이기 위해 사용
    - 실수형 자료형의 정밀도
      실수형|표현 가능한 소수점 이하 자리수
      -|-
      float|소수점 이하 6자리
      double|소수점 이하 15자리
      long double|소수점 이하 15자리 또는 그 이상
  - **실수형**은 `double`형을 선호
    ```c
    #include <stdio.h>
    int main(void){
      float num1 = 0.123456789012345;
      double num2 = 0.123456789012345;

      printf("float형 : %f \n", num1);
      printf("double형 : %lf \n", num2);

      printf("float형 : %.15f \n", num1);
      printf("double형 : %.15lf \n", num2);

      return 0;
    }
    ```

## 6.4 문자형
  - 컴퓨터는 **ASCII** 코드를 참조해서 문자를 인식한다.
  - **문자형**은 `char`형을 선호
  - 문자형 변수에는 반드시 ASCII 코드로 지정된 숫자 또는 문자만 지정 가능
  - 한글은 하나의 글자가 2바이트이므로 char형 변수에 넣을 수 없다.
  - 하나의 문자를 문자형 변수에 넣을 경우 반드시 작은따옴표를 사용

## 6.5 자료형 변환
  - 서로 다른 자료형 간에 연산을 하게 되면 **자료형의 변환**이 발생
  - 자료형의 두가지 방식
    - 자동 형변환 : 컴파일러가 자동으로 수행
    - 강제 형변환 : 프로그래머가 수동으로 수행
  - 자동 형변환
    - 다른 자료형 간에 **산술 연산을 하는 경우**에 발생
      - 연산에 참여하는 피연산자의 자료형은 **정밀도가 작은 자료형이 큰 자료형으로 변환**
    ```
    char => int => long => float => double => long double
    ```
    - **대입 연산을 하는 경우** 대입 연산자를 기준으로 오른쪽에서 왼쪽으로 자동 형변환 발생
  - 강제 형변환
    - **괄호 연산자 ( )**를 사용하여 원하는 자료형으로 강제 형변환할 수 있음
    ```c
    int num1 = 2;
    (double)num1;
    ```

## 6.6 `typedef`를 이용한 자료형의 재정의
  - 자료형을 재정의하면 자료형을 좀 더 간결하게 나타낼 수 있고, 프로그램의 가독성을 높인다.
    ```c
    typedef int mytype;
    ```

---

# 9. 함수란 무엇인가
## 9.1 함수란
  - 함수 : 특정 작업을 수행하는 **코드의 집합**
  - 프로그램을 작성할 시, 함수 단위로 작성하면 코드의 **안정성/ 재사용성이 향상**
  
## 9.2 다양한 형태의 함수들
  - int func(int x, int y) : 11형태
  - int func(void) : 10형태
  - void func(int x, int y) : 01형태
  - void func(void) : 00형태

## 9.3 함수 적용 방법
  - 함수의 정의 => 함수의 호출 : 함수의 정의가 먼저되어 있어야 호출 가능
  - 함수의 선언 => 함수의 호출 => 함수의 정의 : 함수의 선언을 먼저하면 함수의 호출 을 함수의 정의보다 먼저할 수 있다.

## 9.4 변수의 종류와 범위
  - 함수에서 사용되는 변수
    - 지역변수, 전역변수, 정적변수, 외부변수, 레지스터변수
  - 지역변수
    - main() 함수, 조건문, 반복문의 **중괄호 내부**와 **함수의 매개변수**로 사용되는 변수
    - 지역변수의 특징
      - 초기화를 하지 않으면 **쓰레기값이 저장**
      - 지역변수의 메모리 생성 시점 : 중괄호 내에서 초기화할 때
      - 지역변수의 메모리 소멸 시점 : 중괄호를 탈출할 때
  - 전역변수
    - **중괄호 외부**에 선언되는 변수
    - 어느 지역에서도 사용이 제한되지 않는 변수
    - 전역변수는 **반드시 상수로 초기화**해야 한다.
    - 만약 초기화 하지않으면 자동으로 0으로 초기화된다.
    - 전역변수의 특징
      - 초기화를 하지 않아도 **자동으로 0이 저장**
      - 전역변수의 메모리 생성 시점 : 프로그램이 시작될 때
      - 전역변수의 메모리 소멸 시점 : 프로그램이 종료될 때
  - 정적변수
    - **전역변수의 단점을 부분적으로 보완**한 변수
    - 정적변수는 변수의 자료형 앞에 `static` 키워드를 추가
      ```c
      static int num;
      ```
    - 정적변수는 전역변수처럼 프로그램이 종료되지 않는 한 메모리가 소멸되지 않음
    - 전역변수와 마찬가지로 **반드시 상수로 초기화**
    - 전역변수와 마찬가지로 초기화 하지 않으면 자동으로 0으로 초기화
    - 전역변수와 다른점
      - 프로그램이 시작되면 **초기화는 딱 한 번만 수행**
      - 정적변수는 **중괄호 내에서 선언**되므로 중괄호 이외의 영역에서 사용하면 에러 발생
    - 정적변수는 함수의 내부, 조건문, 반복문 등과 같이 중괄호 내부에서 전역변수의 기능을 사용하고 싶을 때 사용
    - 이렇게 중괄호 내에서만 전역변수처럼 사용되는 정적변수를 **정적지역변수**라고 함
    - 정적지역변수의 특징
      - 자료형 앞에 `static` 키워드 붙임
      - 초기화를 하지 않아도 자동으로 0이 저장
      - 반복문의 중괄호 내에서 선언되었더라도 **초기화는 한 번만 수행**
      - 정적지역변수의 메모리 생성 시점 : 중괄호 내에서 초기화될 때
      - 정적지역변수의 메모리 소멸 시점 : 프로그램이 종료될 때
  - 외부변수
    - 외부변수는 현재 파일이 아닌 **외부 파일에서 선언된 변수를 참조**하여 사용하는 변수
    - 외부변수의 특징
      - 자료형 앞에 `extern` 키워드를 붙임
      - 다른 파일에 있는 **전역 변수를 참조**
    - 특정 전역 변수는 외부에서 참조하지 못하게 하고 싶다면 `static` 키워드를 붙인다. 이러한 변수를 **정적전역변수**라고 한다
  - 레지스터변수
    - **CPU 내부의 임시 기억 장소**, 즉 **레지스터에 변수를 할당**하여 값을 저장하는 변수
    - 지역변수는 **CPU 외부의 주기억 장치**에 변수를 할당하므로 입출력 속도가 느림
    - 레지스터변수는 CPU 내부에 있는 레지스터에 변수를 할당하므로 입출력 **속도가 빠름**
    - 레지스터변수를 선언하더라도 CPU 내부의 레지스터가 모자라면 지역변수로 할당된다.

---

# 10. 1차원 배열이란 무엇인가
## 10.1 1차원 배열이란
  - 배열 : **같은 자료형을 가진 연속된 메모리 공간**으로 이루어진 자료구조
  - 배열의 선언
    ```c
    int array[10];
    ```
    - 자료형 : 배열의 자료형을 지정
    - 배열 이름 : 변수 이름과 마찬가지로 배열을 구분하는 이름
    - 배열 길이 : 배열 요소의 총 길이
  - 배열의 초기화
    ```c
    #include <stdio.h>
    int main(void){
      int array1[5] = {90, 80, 70, 60, 50};
      int array2[] = {90, 80, 70, 60, 50}; // 5개의 데이터를 저장하므로 배열길이는 5로 선언됨
      int array3[5] = {90, 80, 70};

      return 0;
    }
    ```
    - **중괄호를 이용**하여 배열에 데이터를 저장
    - 데이터를 저장하지 않은 배열 공간은 **0으로 자동 초기화**
  - 배열 선언 시 주의할 점
    - 배열 초기화를 중괄호로 할 때 배열의 **선언과 초기화는 동시에** 이루어져야 한다.
    ```c
    #include <stdio.h>
    int main(void){
      int array1[3] = {1, 2, 3}; // 정상
      int array2[3];

      array2 = {1, 2, 3};        // 에러 발생

      return 0;
    }
    ```
  - 배열 길이는 **변수가 될 수 없다.**

## 10.2 1차원 배열의 주소와 값의 참조
  - **`&`는 주소를 참조**하는 연산자
  - 변수 이름 앞에 `&` 연산자를 붙여서 변수의 시작 주소를 알 수 있었던 것처럼 배열 요소 앞에 `&` 연산자를 붙이면 각 **배열 요소의 시작 주소**를 알 수 있다.
  - **배열 이름**은 배열의 시작 주소
    ```c
    #include <stdio.h>
    int main(void){
      int array[3] = {1, 2, 3};

      printf("%x %x %x \n", array+0, array+1, array+2);
      printf("%x %x %x \n", &array[0], &array[1], &array[2]);

      return 0;
    }
    ```
    - 배열이름은 배열의 시작 주소를 나타냄
    - 배열이름에 각 요소의 인덱스를 더하면 각 요소의 시작 주소를 나타냄
  - **`*`는 메모리 공간에 저장된 값을 참조**하는 연산자
    ```c
    #include <stdio.h>
    int main(void){
      int array1[3] = {1, 2, 3};

      printf("%d %d %d \n", *&array1[0], *&array1[1], *&array1[2]);
      printf("%d %d %d \n", *&*&array1[0], *&*&array1[1], *&*&array1[2]);
      printf("%d %d %d \n", *array1, *(array1 + 1), *(array1 + 2);

      return 0;
    }
    ```
    ```c
    *array + 3 // 첫 번째 요소의 값에 3을 더함
    *(array + 3) // 네 번째 요소의 값
    *(array + i) == array[i] == *&array[i]
    ```

---

# 11. 다차원 배열이란 무엇인가
## 11.1 다차원 배열이란
  - 2차원 배열의 선언
    ```c
    int array[4][3];
    ```
    - 자료형 : 배열의 자료형을 지정
    - 배열 이름 : 변수 이름과 마찬가지로 배열을 구분하는 배열의 이름
    - 배열 길이 : 배열 요소의 길이를 행과 열로 지정
- 2차원 배열의 초기화
  ```c
  #include <stdio.h>
  int main(void){
    int array1[4][3] = {1,2,3,4,5,6,7,8,9,10,11,12};
    int array2[4][3] = {1,2,3,4,5};

    return 0;
  }
  ```
  - 초기화되지 못한 배열 공간은 **0으로 자동 초기화**
- 2차원 배열을 행 단위로 초기화하기
  ```c
  #include <stdio.h>
  int main(void){
    int array1[4][3] = {{1, 2}, {3}, {4}, {5}};
    int array2[4][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10}};

    return 0;
  }
  ```
  - **중괄호를 중첩하여 사용**하면 행 단위로 배열을 초기화 가능
  - 초기화되지 못한 배열 공간은 **0으로 자동 초기화**
- 2차원 배열을 선언할 때 **열의 길이는 반드시 설정**해야 한다.
  ```c
  int array1[][] = {1,2,3,4,5,6,7,8,9,10,11,12}; // 에러
  int array2[4][] = {1,2,3,4,5,6,7,8,9,10,11,12}; // 에러
  int array3[][3] = {1,2,3,4,5,6,7,8,9,10,11,12}; // 정상
  int array4[][2] = {1,2,3,4,5,6,7,8,9,10,11,12}; // 정상
  int array5[][4] = {1,2,3,4,5,6,7,8,9,10,11,12}; // 정상
  ```

## 11.2 2차원 배열의 주소와 값의 참조
  - 2차원 배열에서도 마찬가지로 **`&` 연산자로 할당된 메모리 공간의 주소를 참조**
  - 2차원 배열의 이름은 **2차원 배열의 시작 주소**이다.
    ```c
    #include <stdio.h>
    int main(void){
      int array[2][2] = {1,2,3,4};
      printf("%x \n", array);     // 0행의 주소
      printf("%x \n", array + 1); // 1행의 주소
      return 0;
    }
    ```
  - 2차원 배열의 행의 요소는 **행을 대표하는 주소**이다.
    ```c
    #include <stdio.h>
    int main(void){
      int array[2][2] = {10, 20, 30, 40};

      printf("%x %x \n", array[0], &array[0][0]); // 0행의 대표 주소
      printf("%x %x \n", array[1], &array[1][0]); // 1행의 대표 주소  

      return 0;
    }
    ```
      - 1차원 배열과 달리 array[0]은 값이 아니라 0행을 대표하는 주소이다.
      - 즉 0행 0열의 주소
  - 2차원 배열에서 array[i], *(array + i)는 i행의 주소를 표현
    - 1차원 배열에서 array[i], *(array + i)는 **i행의 값을 표현**
    - 하지만 2차원 배열에서 array[i], *(array + i)는 **i행의 주소를 표현**
    - ***주의할 점*** : 2차원 배열에서는 array + i도 i행의 주소를 나타낸다
    ```c
    #include <stdio.h>
    int main(void){
      int array[2][2] = {1,2,3,4};

      printf("%x %x \n", &array[0][0], &array[0][1]);
      printf("%x %x \n", &array[1][0], &array[1][1]);
      printf("======================\n");
      printf("%x %x \n", array[0] + 0, array[0] + 1);
      printf("%x %x \n", array[1] + 0, array[1] + 1);
      printf("======================\n");
      printf("%x %x \n", *(array + 0) + 0, *(array + 0) + 1);
      printf("%x %x \n", *(array + 1) + 0, *(array + 1) + 1);
      return 0;
    }
    ```
      - 주소연산에서 +0, +1의 의미는 **선언된 자료형의 크기만큼 더하라는 의미**이다
