---
layout: post
title:  "자료구조 정리"
date:   2018-10-19 18:19:02 +0900
---

### 1. 자료구조와 알고리즘
* 자료구조
	- 컴퓨터에서 자료들을 정리하고 조직화 하는 여러가지 구조들을 자료구조라 한다

	- 자료구조의 분류

		1. 선형 자료구조 : 배열, 연결 리스트, 스택, 큐, 덱
		2. 비선형 자료구조 : 트리, 그래프

	- 알고리즘이란
		1. 컴퓨터가 주어진 상태에서 문제를 해결하는 방법을 장치가 이해할 수 있는 언어로 정밀하게 기술한것
		2. 효율적인 알고리즘은 전체 실행 시간이 짧으면서 메모리와 같은 컴퓨터의 자원들을 적게 사용하는 알고리즘

	- 실행 시간 분석 : 시간 복잡도
		1. 알고리즘을 이루고 있는 연산(산술, 대입, 비교, 이동 연산 등)들이 몇 번이나 실행되는지 숫자로 표시한 것
		2. 시간 복잡도 함수에서 중요한 것은 n이 증가함에 따라 무엇에 비례하는 수의 연산인가가 중요

	- 기억 공간 분석 : 공간 복잡도


---


### 2. 배열과 클래스
* 배열
	- 주로 여러 개의 동일한 자료형의 데이터를 한꺼번에 만들 때 사용
	- 동일한 이름을 사용하고 인덱스 번호로 각 항목을 접근
	- 모든 요소가 동일한 자료형이며, 인덱스를 사용하여 요소로 직접 접근이 가능

---


### 3. 스택
* 스택
	- 쌓인 접시더미와 같다
	- 입출력 형태는 후입 선출(Last IN First OUT)


---


### 4. 큐
* 큐
	- 먼저 들어온 데이터가 먼저 나가는 자료구조
	- 선입 선출(First IN First Out)

* 덱
	- double ended queue
	- 큐의 전단과 후단에서 모두 삽입과 삭제가 가능한 큐
	- 여전히 중간 삽입/ 삭제는 불가능


---


### 5. 포인터와 연결 리스트
* 연결리스트
	- 배열로 스택과 큐를 구현하면 간단하고 빠르지만 크기가 고정된다는 단점
	- 동적으로 크기가 변할 수 있는 방법은?
	- 연결된 표현을 사용!
	- 물리적으로 흩어져 있는 자료들을 서로 연결하여 하나로 묶는 방법을 연결 리스트라고 한다
	- C++에서는 포인터로 구현
	- 크기가 고정되지 않음
	- 중간에 자료를 삽입/ 삭제하는 것이 용이
	- 단점 : 동적할당과 해제가 너무 빈번하게 일어나면 프로그램이 느려질 수 있다


---


### 6. 리스트
* 리스트란?
	- 자료구조에서 리스트는 특정한 자료 구조를 말하고 연결리스트는 어떤 자료구조를 구현하는 프로그래밍 기법
	- 리스트도 스택이나 큐와 같이 배열을 사용할 수도 있고 포인터를 이용한 연결 리스트로 구현할 수도 있다
	- 리스트는 삽입 삭제를 임의의 위치에서 가능


---


### 8. 트리
* 트리의 개념
	- 선형 자료구조가 아닌 계층적인 구조를 표현하는데 이용하는 자료구조
	- 트리는 한 개 이상의 노드로 이루어진 유한 집합
	- 자식 노드가 없는 노드는 단말 노드
	- 차수 : 어떤 노드가 가지고 있는 자식 노드의 개수
	- 단말 노드는 차수가 0
	- 트리의 차수 : 트리가 가지고 있는 노드 중 최대 차수
	- 레벨 : 루트의 레벨 1부터 아래로 내려가면서 1씩 증가
	- 트리의 높이 : 트리가 가지고 있는 최대 레벨

* 이진트리
	- 모든 노드가 2개의 서브트리를 갖는 트리(서브 트리는 공집합일 수도 있다)

	- 이진트리의 성질
		1. n개의 노드를 가진 트리는 n-1개의 간선을 가진다
		2. 높이가 h인 이진트리는 h개 이상, 2^h-1개 이하의 노드를 가진다
		3. n개의 노드를 가진 이진트리의 높이는 log2(n+1)이상 n이하이다

	- 포화 이진트리
		1. 트리의 각 레벨에 노드가 꽉 차있는 이진 트리

	_ 완전 이진트리
		1. 높이가 k인 트리에서 레벨 1부터 k-1까지는 노드가 모두 채워져 있고 마지막 레벨 k에서는 왼쪽부터 오른쪽으로 노드가 순서대로 채워진 이진트리
		2. 마지막 레벨에서는 노드가 꽉 차있지 않아도 된다

* 이진트리의 순회
	- 트리에 속하는 모든 노드를 한 번씩 방문하여 노드가 가지고 있는 데이터를 목적에 맞게 처리하는 것
	- 이진트리 순회 방법
		1. 전위 순회(VLR) : 루트 먼저 방문하고 왼쪽 서브트리 방문하고 오른쪽 서브트리 방문
		2. 중위 순회(LVR) : 왼쪽 서브트리, 루트, 오른쪽 서브트리 순으로 방문
		3. 후위 순회(LRV) : 왼쪽 서브트리, 오른쪽 서브트리, 루트 순으로 방문


---


### 9. 이진 탐색 트리
* 이진 탐색 트리(Binary Search Tree)
	- 이진트리 기반의 탐색을 위한 자료구조로 효율적인 탐색 작업을 위한 자료구조
		1. 모든 노드는 유일한 키를 갖는다
		2. 왼쪽 서브트리의 키들은 루트의 키보다 작다
		3. 오른쪽 서브트리의 키들은 루트의 키보다 크다
		4. 왼쪽과 오른쪽 서브트리도 이진 탐색 트리다

* 이진 탐색 트리의 연산
	- 탐색연산
		1. 이진 탐색 트리에서 어떤 탐색키를 가진 노드를 찾기 위해서는 먼저 주어진 탐색키와 현재의 루트 노드의 키 값을 비교해야 한다
		2. 비교한 결과가 같으면 탐색이 성공
		3. 비교한 결과 탐색키가 루트 노드의 키 값보다 작으면 탐색은 이 루트 노드의 왼쪽자식 기준으로 다시 시작
		4. 비교한 결과 탐색키가 루트 노드의 키 값보다 크면 탐색은 이 루트 노드의 오른쪽자식 기준으로 다시 시작

	- 삽입연산
		1. 이진 탐색 트리에 원소를 삽입하기 위해서는 먼저 탐색을 수행하는 것이 필요
		2. 이진 탐색 트리에서는 같은 키를 갖는 노드가 없기 때문에 탐색에 실패한 위치가 바로 새로운 노드를 삽입하는 위치이다

	- 삭제연산
		1. 노드를 삭제하기 위해서는 먼저 노드를 탐색
		2. 3가지 경우를 고려한다
		3. 삭제하려는 노드가 단말 노드일 경우
			- 그냥 지운다
		4. 삭제하려는 노드가 왼쪽이나 오른쪽 서브트리 중 하나만 가지고 있는 경우
			- 그 노드는 삭제하고 삭제된 노드의 유일한 자식을 부모 노드에 붙힌다
		5. 삭제하려는 노드가 두 개의 서브트리 모두 가지고 있는 경우
			- 삭제되는 노드와 가장 값이 비슷한 노드를 부모노드에 연결하여야 다른 노드를 이동시키지 않아도 이진 탐색 트리가 유지될 수 있다
			- 가장 값이 가까운 노드는 왼쪽 서브트리에서 가장 큰 값이나 오른쪽 서브트리에서 가장 작은값이 삭제하려는 노드의 값과 가장 가깝다
			- 이들 노드는 이진 탐색 트리를 중위 순회했를 때, 각각 삭제할 노드의 바로 앞과 뒤에 방문되는 노드이다
			- 둘 중 어느 것을 선택해도 된다
			- 만약 오른쪽 서브트리의 가장 작은 값을 선택한다면 오른쪽 서브트리에서 왼쪽 자식 링크를 타고 NULL을 만난 때까지 계속 진행하면 된다

* 이진 탐색 트리의 성능 분석
	- 시간복잡도는 O(log2n)


---


### 10. 우선순위 큐
* 우선순위 큐
	- 데이터들이 우선순위를 가지고 있어 우선순위가 높은 데이터가 먼저 출력되는 큐
	- 힙을 사용하여 구현

* 힙
	- 완전 이진트리의 일종으로 우선순위 큐를 위해 만들어진 자료구조
	- 힙은 여러 개의 값들 중에서 가장 큰 값이나 가장 작은 값을 빠르게 찾아내도록 만들어진 자료구조
	- 부모 노드의 키 값이 자식 노드의 키 값보다 항상 크거나 같은 완전 이진트리(최대 힙)
	- 부모 노드의 키 값이 자식 노드의 키 값보다 항상 작거나 같은 완전 이진트리(최소 힙)
	- 중복된 값을 허용(이진 탐색트리는 중복된 값을 허용하지 않는다)

* 힙의 구현 방법
	- 힙을 저장하는 효과적인 자료구조는 배열

* 삽입 연산
	- 회사에서 신입사원이 들어오면 일단 말단 위치에 앉힌 다음, 위로 올린다

* 삭제 연산
	- 힙에서 삭제 연산은 루트 노드를 삭제하는 것
	- 루트 노드가 삭제
	- 빈 루트 노드에 힙의 마지막 노드를 올린다
	- 아래와 비교하면서 자리를 바꾼다

* 힙의 복잡도 분석
	- 삽입/ 삭제의 시간복잡도는 모두 O(log2n)

* 허프만 코드
	- 각 글자의 빈도수에 따라서 가장 많이 등장하는 글자에는 짧은 비트열을 사용하고 잘 나오지 않는 글자에는 긴 비트열을 사용하여 전체의 크기를 줄이는 방법


---


### 11. 그래프
* 그래프
	- 요소들이 서로 복잡하게 연결되어 있는 관계를 표현하는 자료구조
	- 그래프의 용어
		1. 인접 정점 : 간선에 의해 직접 연결된 정점
		2. 정점의 차수 : 정점에 연결된 간선의 수
		3. 연결그래프 : 모든 정점들 사이에 경로가 존재하면 연결그래프
		4. 완전그래프 : 모든 정점 간에 간선이 존재하는 그래프

* 그래프의 탐색
	- 깊이 우선 탐색(depth first search)
		1. 시작 정점에서부터 임의의 인접한 정점으로 깊이 탐색을 진행
		2. 방문한 정점은 반드시 방문되었다는 표시를 한다
		3. 만약 현재 정점에서 더 이상 방문하지 않은 인접 정점이 없으면 가장 마지막에 만났던 정점으로 돌아간다
		4. 거기서 다시 아직 방문하지 않은 인접 정점을 창아 동일한 방법으로 탐색

	- 너비 우선 탐색(breath first search)
		1. 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회방법
		2. 가까운 거리에 있는 정점들을 차례로 저장하고 들어간 순서대로 꺼낼 수 있는 자료구조가 필요(큐)
		3. 정점들이 방문될 때마다 큐에 인접 정점을 삽입하고 더이상 방문할 인접정점이 없는 경우 큐의 맨 앞에서 정점을 꺼내 그 정점과 인접한 정점을 차례대로 방문
