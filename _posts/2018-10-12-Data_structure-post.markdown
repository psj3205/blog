---
layout: post
title:  "자료구조 정리"
date:   2018-10-19 18:19:02 +0900
---

### 1. 자료구조와 알고리즘
* 자료구조
	- 컴퓨터에서 자료들을 정리하고 조직화 하는 여러가지 구조들을 자료구조라 한다

	- 자료구조의 분류

		1. 선형 자료구조 : 배열, 연결 리스트, 스택, 큐, 덱
		2. 비선형 자료구조 : 트리, 그래프

	- 알고리즘이란
		1. 컴퓨터가 주어진 상태에서 문제를 해결하는 방법을 장치가 이해할 수 있는 언어로 정밀하게 기술한것
		2. 효율적인 알고리즘은 전체 실행 시간이 짧으면서 메모리와 같은 컴퓨터의 자원들을 적게 사용하는 알고리즘

	- 실행 시간 분석 : 시간 복잡도
		1. 알고리즘을 이루고 있는 연산(산술, 대입, 비교, 이동 연산 등)들이 몇 번이나 실행되는지 숫자로 표시한 것
		2. 시간 복잡도 함수에서 중요한 것은 n이 증가함에 따라 무엇에 비례하는 수의 연산인가가 중요

	- 기억 공간 분석 : 공간 복잡도


---


### 2. 배열과 클래스
* 배열
	- 주로 여러 개의 동일한 자료형의 데이터를 한꺼번에 만들 때 사용
	- 동일한 이름을 사용하고 인덱스 번호로 각 항목을 접근
	- 모든 요소가 동일한 자료형이며, 인덱스를 사용하여 요소로 직접 접근이 가능

---


### 3. 스택
* 스택
	- 쌓인 접시더미와 같다
	- 입출력 형태는 후입 선출(Last IN First OUT)


---


### 4. 큐
* 큐
	- 먼저 들어온 데이터가 먼저 나가는 자료구조
	- 선입 선출(First IN First Out)

* 덱
	- double ended queue
	- 큐의 전단과 후단에서 모두 삽입과 삭제가 가능한 큐
	- 여전히 중간 삽입/ 삭제는 불가능


---


### 5. 포인터와 연결 리스트
* 연결리스트
	- 배열로 스택과 큐를 구현하면 간단하고 빠르지만 크기가 고정된다는 단점
	- 동적으로 크기가 변할 수 있는 방법은?
	- 연결된 표현을 사용!
	- 물리적으로 흩어져 있는 자료들을 서로 연결하여 하나로 묶는 방법을 연결 리스트라고 한다
	- C++에서는 포인터로 구현
	- 크기가 고정되지 않음
	- 중간에 자료를 삽입/ 삭제하는 것이 용이
	- 단점 : 동적할당과 해제가 너무 빈번하게 일어나면 프로그램이 느려질 수 있다


---


### 6. 리스트
* 리스트란?
	- 자료구조에서 리스트는 특정한 자료 구조를 말하고 연결리스트는 어떤 자료구조를 구현하는 프로그래밍 기법
	- 리스트도 스택이나 큐와 같이 배열을 사용할 수도 있고 포인터를 이용한 연결 리스트로 구현할 수도 있다
	- 리스트는 삽입 삭제를 임의의 위치에서 가능


---


### 8. 트리
* 트리의 개념
	- 선형 자료구조가 아닌 계층적인 구조를 표현하는데 이용하는 자료구조
	- 트리는 한 개 이상의 노드로 이루어진 유한 집합
	- 자식 노드가 없는 노드는 단말 노드
	- 차수 : 어떤 노드가 가지고 있는 자식 노드의 개수
	- 단말 노드는 차수가 0
	- 트리의 차수 : 트리가 가지고 있는 노드 중 최대 차수
	- 레벨 : 루트의 레벨 1부터 아래로 내려가면서 1씩 증가
	- 트리의 높이 : 트리가 가지고 있는 최대 레벨

* 이진트리
	- 모든 노드가 2개의 서브트리를 갖는 트리(서브 트리는 공집합일 수도 있다)

	- 이진트리의 성질
		1. n개의 노드를 가진 트리는 n-1개의 간선을 가진다
		2. 높이가 h인 이진트리는 h개 이상, 2^h-1개 이하의 노드를 가진다
		3. n개의 노드를 가진 이진트리의 높이는 log2(n+1)이상 n이하이다

	- 포화 이진트리
		1. 트리의 각 레벨에 노드가 꽉 차있는 이진 트리

	_ 완전 이진트리
		1. 높이가 k인 트리에서 레벨 1부터 k-1까지는 노드가 모두 채워져 있고 마지막 레벨 k에서는 왼쪽부터 오른쪽으로 노드가 순서대로 채워진 이진트리
		2. 마지막 레벨에서는 노드가 꽉 차있지 않아도 된다

* 이진트리의 순회
	- 트리에 속하는 모든 노드를 한 번씩 방문하여 노드가 가지고 있는 데이터를 목적에 맞게 처리하는 것
	- 이진트리 순회 방법
		1. 전위 순회(VLR) : 루트 먼저 방문하고 왼쪽 서브트리 방문하고 오른쪽 서브트리 방문
		2. 중위 순회(LVR) : 왼쪽 서브트리, 루트, 오른쪽 서브트리 순으로 방문
		3. 후위 순회(LRV) : 왼쪽 서브트리, 오른쪽 서브트리, 루트 순으로 방문


---


### 9. 이진 탐색 트리
* 이진 탐색 트리(Binary Search Tree)
	- 이진트리 기반의 탐색을 위한 자료구조로 효율적인 탐색 작업을 위한 자료구조
		1. 모든 노드는 **유일한 키**를 갖는다
		2. 왼쪽 서브트리의 키들은 루트의 키보다 **작다**
		3. 오른쪽 서브트리의 키들은 루트의 키보다 **크다**
		4. 왼쪽과 오른쪽 서브트리도 이진 탐색 트리다

* 이진 탐색 트리의 연산
	- 탐색연산
		1. 이진 탐색 트리에서 어떤 탐색키를 가진 노드를 찾기 위해서는 먼저 주어진 탐색키와 현재의 루트 노드의 키 값을 비교해야 한다
		2. 비교한 결과가 같으면 탐색이 성공
		3. 비교한 결과 탐색키가 루트 노드의 키 값보다 작으면 탐색은 이 루트 노드의 왼쪽자식 기준으로 다시 시작
		4. 비교한 결과 탐색키가 루트 노드의 키 값보다 크면 탐색은 이 루트 노드의 오른쪽자식 기준으로 다시 시작

	- 삽입연산
		1. 이진 탐색 트리에 원소를 삽입하기 위해서는 먼저 탐색을 수행하는 것이 필요
		2. 이진 탐색 트리에서는 같은 키를 갖는 노드가 없기 때문에 탐색에 실패한 위치가 바로 새로운 노드를 삽입하는 위치이다

	- 삭제연산
		1. 노드를 삭제하기 위해서는 먼저 노드를 탐색
		2. 3가지 경우를 고려한다
		3. 삭제하려는 노드가 단말 노드일 경우
			- 그냥 지운다
		4. 삭제하려는 노드가 왼쪽이나 오른쪽 서브트리 중 하나만 가지고 있는 경우
			- 그 노드는 삭제하고 삭제된 노드의 유일한 자식을 부모 노드에 붙힌다
		5. 삭제하려는 노드가 두 개의 서브트리 모두 가지고 있는 경우
			- 삭제되는 노드와 가장 값이 비슷한 노드를 부모노드에 연결하여야 다른 노드를 이동시키지 않아도 이진 탐색 트리가 유지될 수 있다
			- 가장 값이 가까운 노드는 왼쪽 서브트리에서 가장 큰 값이나 오른쪽 서브트리에서 가장 작은값이 삭제하려는 노드의 값과 가장 가깝다
			- 이들 노드는 이진 탐색 트리를 중위 순회했를 때, 각각 삭제할 노드의 바로 앞과 뒤에 방문되는 노드이다
			- 둘 중 어느 것을 선택해도 된다
			- 만약 오른쪽 서브트리의 가장 작은 값을 선택한다면 오른쪽 서브트리에서 왼쪽 자식 링크를 타고 NULL을 만난 때까지 계속 진행하면 된다

* 이진 탐색 트리의 성능 분석
	- 시간복잡도는 O(log2n)


---


### 10. 우선순위 큐
* 우선순위 큐
	- 데이터들이 우선순위를 가지고 있어 우선순위가 높은 데이터가 먼저 출력되는 큐
	- 힙을 사용하여 구현

* 힙
	- 완전 이진트리의 일종으로 우선순위 큐를 위해 만들어진 자료구조
	- 힙은 여러 개의 값들 중에서 가장 큰 값이나 가장 작은 값을 빠르게 찾아내도록 만들어진 자료구조
	- 부모 노드의 키 값이 자식 노드의 키 값보다 항상 크거나 같은 완전 이진트리(최대 힙)
	- 부모 노드의 키 값이 자식 노드의 키 값보다 항상 작거나 같은 완전 이진트리(최소 힙)
	- 중복된 값을 허용(이진 탐색트리는 중복된 값을 허용하지 않는다)

* 힙의 구현 방법
	- 힙을 저장하는 효과적인 자료구조는 배열

* 삽입 연산
	- 회사에서 신입사원이 들어오면 일단 말단 위치에 앉힌 다음, 위로 올린다

* 삭제 연산
	- 힙에서 삭제 연산은 루트 노드를 삭제하는 것
	- 루트 노드가 삭제
	- 빈 루트 노드에 힙의 마지막 노드를 올린다
	- 아래와 비교하면서 자리를 바꾼다

* 힙의 복잡도 분석
	- 삽입/ 삭제의 시간복잡도는 모두 O(log2n)

* 허프만 코드
	- 각 글자의 빈도수에 따라서 가장 많이 등장하는 글자에는 짧은 비트열을 사용하고 잘 나오지 않는 글자에는 긴 비트열을 사용하여 전체의 크기를 줄이는 방법


---


### 11. 그래프
* 그래프
	- 요소들이 서로 복잡하게 연결되어 있는 관계를 표현하는 자료구조
	- 그래프의 용어
		1. 인접 정점 : 간선에 의해 직접 연결된 정점
		2. 정점의 차수 : 정점에 연결된 간선의 수
		3. 연결그래프 : 모든 정점들 사이에 경로가 존재하면 연결그래프
		4. 완전그래프 : 모든 정점 간에 간선이 존재하는 그래프

* 그래프의 탐색
	- 깊이 우선 탐색(depth first search)
		1. 시작 정점에서부터 임의의 인접한 정점으로 깊이 탐색을 진행
		2. 방문한 정점은 반드시 방문되었다는 표시를 한다
		3. 만약 현재 정점에서 더 이상 방문하지 않은 인접 정점이 없으면 가장 마지막에 만났던 정점으로 돌아간다
		4. 거기서 다시 아직 방문하지 않은 인접 정점을 창아 동일한 방법으로 탐색

	- 너비 우선 탐색(breath first search)
		1. 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회방법
		2. 가까운 거리에 있는 정점들을 차례로 저장하고 들어간 순서대로 꺼낼 수 있는 자료구조가 필요(큐)
		3. 정점들이 방문될 때마다 큐에 인접 정점을 삽입하고 더이상 방문할 인접정점이 없는 경우 큐의 맨 앞에서 정점을 꺼내 그 정점과 인접한 정점을 차례대로 방문


---

### 13. 정렬
* 정렬이란?
	- 물건을 크기순으로 **오름차순이나 내림차순으로 나열**하는 것

	- 정렬 알고리즘의 분류
		1. 단순하지만 비효율적인 방법 : **삽입 정렬, 선택 정렬, 버블 정렬**
		2. 복잡하지만 효율적인 방법 : **퀵 정렬, 힙 정렬, 합병 정렬, 기수 정렬**

* 선택 정렬(Selection sort)
	- 정렬이 안된 리스트에서 **최솟값**이 선택되면 이 값을 배열의 첫 번째 요소와 교환
	- 첫 번째 요소를 제외한 나머지 배열에서 위와 같은 방법으로 최솟값을 찾고 두 번째 요소와 교환
	- 배열 끝까지 위 방법 반복
	- **시간 복잡도 : O(n^2*)**

* 삽입 정렬(Insertion sort)
	- 손 안의 카드를 정렬하는 방법과 유사
	- 카드를 한 장씩 받을 때 새로운 카드를 먼저 받아 정렬한 카드들 사이의 올바른 자리에 넣는 것
	- **시간 복잡도 : O(n^2)**

* 버블 정렬(Bubble sort)
	- 인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환하는 방법
	- **시간 복잡도 : O(n^2)**

* 합병 정렬(Merge sort)
	- 하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 리스트를 합하여 전체가 정렬된 리스트를 만드는 방법
	- 입력 데이터가 어떻게 이루어져 있는지에 상관없이, 모두 동일한 시간에 정렬됨
	- **시간 복잡도 : O(nlog2n)**

* 퀵 정렬(quick sort)
	- 합병 정렬과 같이 **분할-정복법**을 사용하지만 **리스트를 균등하게 분할하지 않는다**
	- **시간 복잡도 : O(nlog2n)**

* 힙 정렬(Heap sort)
	- **정렬할 배열을 먼저 최소 힙으로 변환한 다음**, 가장 작은 원소부터 차례대로 추출하여 정렬하는 방법
	- **시간 복잡도 : O(nlog2n)**

### 14. 탐색
* 탐색
	- 탐색이란?
		1. 하나 이상의 **필드**로 구성되는 **레코드**의 집합에서 원하는 레코드를 찾나내는 작업. 이러한 레코드의 집합을 **테이블**이라한다.
		2. 레코드들은 서로 중복되지 않고 고유한 값을 가지는 키를 가지는데, 이것을 **탐색키**라고 한다.
		3. 결국 자료를 탐색하는 것은 테이블에서 원하는 탐색키를 가진 레코드를 찾는 것

	- 맵이란?
		1. 맵은 탐색을 위한 자료구조
		2. 맵 또는 사전은 자료를 저장하고 키를 이용해 원하는 자료를 빠르게 찾을 수 있도록 하는 자료구조
		3. 맵은 **키를 가진 레코드(keyed record)** 또는 **엔트리(entry)**라 불리는 키-값 쌍을 테이블에 저장한다
		4. 각 키는 유일하고 맵에 저장되는 키와 값은 어떠한 자료형도 가능하다
		5. 맵을 가장 효율적으로 구현할 수 있는 방법은 **해싱**이다.

	- 해싱을 이용한 탐색
		1. 해싱은 키값을 비교하는 것이 아니라 **탐색키에 산술적인 연산을 적용하여 항목이 저장되어 있는 위치, 즉 인덱스를 직접 계산하는 방식**이다.
		2. 키값의 연산에 의해 직접 접근이 가능한 구조를 **해시 테이블**이라 하며, 해시 테이블을 이용한 탐색을 **해싱**이라 한다.
		3. 서로 다른 키 k1, k2가 해시함수에 의해 같은 주소로 계산되는 상황이 발생하는데, 이것을 **충돌(collision)**이라 한다.
		4. 충돌이 슬롯 수보다 더 많이 발생할 경우를 **오버플로우**라고 한다.

	- 해시 함수
		1. 충돌이 적어야 한다.
		2. 해시 함수 값이 해시 테이블의 주소 영역 내에서 고르게 분포되어야 한다.
		3. 계산이 빨라야 한다.
		
	- 해싱의 오버플로우 처리 방법
		1. 선형 조사법(linear probing) : 충돌이 일어나면 해시 테이블의 다른 위치를 찾아 항목을 저장한다
		2. 체이닝(chaining) : 해시 테이블의 하나의 위치가 여러 개의 항목으로 저장할 수 있도록 해시 테이블의 구조를 변경한다

	- 선형 조사법
		1. 해싱 함수로 구한 버켓에 빈 슬롯이 없으면 그 다음 버켓에서 빈 슬롯이 있는지를 찾는 방법이다.

