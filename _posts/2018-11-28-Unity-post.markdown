---
layout: post
title:  "Unity 정리"
date:   2018-11-28 14:17:02 +0900
---

### 1. 게임 스테이지 제작
* 텍스처
	- 3D 모델의 표면에 매핑시킬 이미지 파일을 지칭
	- 마네킹에 다양한 옷을 입힐 수 있는 것처럼 3D 모델에 텍스처를 입힌다고 표현하면 이해하기 쉬움
	- 텍스처의 크기는 가로세로 2n 형태일 때 압축을 지원하며 속도가 가장 빠름

* 머티리얼
	- 3D 모델과 텍스처 사이를 이어주는 매개체가 머티리얼
	- 머티리얼은 3D 모델에 적용할 텍스처의 다양한 속성을 설정하는 역할

* 셰이더 및 물리 기반 셰이딩
	- 셰이더는 머티리얼에 적용한 텍스처를 렌더링할 때 표면의 재질감을 표현하는 방식을 결정

* 프리팹
	- 자주 사용하는 객체를 미리 만들어 놓고 재사용할 수 있게하는 것
	- 복사가 가능한 원본의 개념
	- 프리팹을 수정하면 그 복사본은 수정사항이 자동으로 일괄적으로 적용
	- 개발 관리 측면에서 효율적
	- 다른 프로젝트에도 쉽게 임포트하여 사용 가능

* 게임 오브젝트 텍스처 적용 과정
	- 머티리얼 파일 생성
	- 머티리얼을 선택하여 Inspector 뷰에서 원하는 텍스처를 Albedo에 지정
	- 해당 3D 모델의 Mesh Renderer 컴포넌트의 Materials 속성에 원하는 머티리얼을 지정

* Mesh Filter, Mesh Renderer 컴포넌트
	- 3D 모델에는 항상 Mesh Filter와 Mesh Renderer 컴포넌트가 존재
	- Mesh Filter 컴포넌트는 해당 모델의 3차원 형상 정보인 Mesh 데이터를 가지고 있음
	- Mesh Renderer 컴포넌트는 이 Mesh 데이터를 토대로 화면에 렌더링 처리를 하는 컴포넌트

---

### 2. 캐릭터 제작
* 스크립트
	- Awake
		1. 스크립트가 실행될 때 한 번만 호출되는 함수
		2. 주로 게임의 상태 값 또는 변수의 초기화에 사용
		3. Start 함수가 호출되기 전에 맨 먼저 호출
		4. 스크립트가 비활성화 되어 있어도 실행
		5. 코루틴 사용불가
	- Start
		1. Update 함수가 호출되기 전에 한 번만 호출
		2. 스크립트가 활성화 되어 있어야 실행
		3. 다른 스크립트의 모든 Awake가 모두 다 실행된 이후에 실행
	- Update
		1. 프레임마다 호출되는 함수로 주로 게임의 핵심 로직을 작성
		2. 스크립트가 활성화 되어 있어야 실행
	- LateUpdate
		1. 모든 Update 함수가 호출되고 나서 한 번씩만 호출
		2. 순차적으로 실행해야 하는 로직에 사용
		3. 카메라 이동 로직에 주로 사용하는 함수
		4. 스크립트가 활성화 되어 있어야 실행
	- FixedUpdate
		1. 주로 물리 엔진을 사용하는 경우에 일정 시간 간격으로 힘을 가할 때 사용하는 함수
		2. 발생하는 주기가 일정
	- OnEnable
		1. 게임오브젝트 또는 스크립트가 활성화 되었을 때 호출
		2. 이벤트 연결 시 사용
		3. 코루틴 사용 불가
	- OnDisable
		1. 게임오브젝트 또는 스크립트가 비활성화 되었을 때 호출
		2. 이벤트 연결을 종료할 때 사용
		3. 코루틴 사용 불가
	
---

### 3. 발사체 제작
* Rigidbody 컴포넌트
	- Rigidbody 컴포넌트를 게임오브젝트에 추가하면 해당 게임오브젝트는 중력의 영향을 즉시 받기 시작
	- Collider 컴포넌트도 하나 이상 추가할 경우 게임 오브젝트가 당하는 충돌에 의해 움직임
	- Rigidbody 컴포넌트는 연결된 게임 오브젝트의 이동을 제어하므로 스크립트에서 포지션과 회전 같은 트랜스폼 프로퍼티를 변경하여 오브젝트를 이동하면 안됨
	- 대신 Forces를 가하여 게임 오브젝트를 밀고 물리 엔진이 결과를 계산하도록 해야 함
	- 게임 오브젝트에 리지드바디를 연결하되, 물리 엔진으로 모션이 제어되는 것을 원치 않는 경우 is Kinematic 프로퍼티를 선택
	- 하지만 성능 오버헤드가 발생하므로 신중해야 함
* Collider 컴포넌트
	- 충돌을 감지하기 위한 컴포넌트

* 충돌감지 조건
	- 충돌을 일으키는 양쪽 오브젝트 모두 Collider 컴포넌트가 있어야 함
	- 두 게임오브젝트 중 움직이는 쪽에는 반드시 Rigidbody 컴포넌트가 있어야 함

* 정적 콜라이더
	- 콜라이더는 있지만 리지드바디는 없는 게임 오브젝트
	- 리지드바디 오브젝트가 다가오면 정적 콜라이더와 충돌하지만 정적 콜라이더는 움직이지 않음

* 리지드바디 콜라이더
	- 일반 비키네마틱 리지드바디와 콜라이더가 있는 게임 오브젝트
	- 리지드바디 콜라이더는 물리 엔진에 의해 완전히 시뮬레이션되며 스크립트로부터 적용되는 충돌과 힘에 반응

* 키네마틱 리지드바디 콜라이더
	- 키네마틱 리지드바디오브젝트는 Transform 컴포넌트를 수정하여 스크립트를 통해 움직일 수 있음
	- 하지만 비키네마틱 리지드바디의 경우와 같은 충돌이나 힘에는 반응하지 않음

---

### 추가항목. 드로우콜(배치)
* 드로우 콜(배치)
	- 오브젝트, 파티클 등 CPU에 의해 연산된 정보를 GPU에 넘겨주어 최종적으로 GPU가 화면에 출력한다
	- 이 때 CPU가 GPU를 호출하는 것을 드로우 콜이라고 한다

* Set Pass Call
	- 머티리얼과 쉐이더에 관련된 것에 대한 배치
	- 아틀라스를 활용하여 여러 오브젝트들을 한개의 머티리얼로 묶어서 Set Pass Call을 감소시켜야 한다

* 아틀라스
	- 오브젝트의 수가 많더라도 같은 텍스처를 사용한다면 드로우콜은 한번만 발생
	- 따라서 하나의 텍스처에 많은 이미지들을 모아서 드로우콜을 감소시킨다
	- 이것을 아틀라스라고 한다
	
* 배칭 
	- 복수의 드로우콜을 하나의 드로우콜로 묶어서 처리하는 작업
	- CPU가 GPU에 랜더링 요청을 할 때 데이터 처리 작업을 한꺼번에 해줘서 GPU의 부담을 줄인다

* 동적 배칭
	- 동일한 머티리얼을 공유하고, 버텍스 개수가 총 300이하의 메쉬만 적용 가능(이외의 조건 존재)
	- 유니티에 의해 자동 적용

* 정적 배칭
	- 동일한 머터리얼을 공유하고, 움직이지 않는 오브젝트에 적용할 수 있는 배칭
	- 적용 효과가 크다
	- 메쉬를 강제적으로 합쳐서 메모리에 부담을 준다

* 리얼타임 쉐도우
	- 리얼타임 쉐도우를 해제