---
layout: post
title:  "STL 정리"
date:   2018-12-01 14:21:02 +0900
---

### 6. 시퀀스 컨테이너
* vector 컨테이너
	- vector는 시퀀스 컨테이너이므로 원소의 저장 위치가 정해진다
	- 또한 배열 기반 컨테이너이므로 원소가 하나의 메모리 블록에 할당된다
	- 앞쪽이 막혀 있는 형태로 앞쪽에는 원소를 추가/제거할 수 없으며 뒤쪽에만 추가/제거할 수 있다
	- STL의 모든 컨테이너는 양방향 반복자 이상의 기능을 제공
	- vector는 임의접근 반복자를 제공, + - += -= [] 연산 가능

* deque 컨테이너
	- deque는 시퀀스 컨테이너이며 배열 기반 컨테이너이다
	- deque은 원소를 앞쪽 뒤쪽에 모두 추가할 수 있음
	- 여러개의 메모리 블록을 할당하고 원소의 추가 시 메모리가 부족할 경우 일정한 크기의 새로운 메모리 블록을 할당하여 하나의 블록처럼 사용
	- vector는 새로운 메모리 블록을 할당하고 값을 복사한 뒤 기존의 블록은 삭제
	- deque은 임의접근 반복자를 제공, + - += -= [] 연산 가능

* list 컨테이너
	- list 컨테이너는 vector와 deque처럼 시퀀스 컨테이너로 원소가 상대적인 순서를 유지
	- 그러나 list는 노드 기반 컨테이너로 원소가 노드 단위로 저장된다(이중 연결 리스트로 구현)
	- 컨테이너 앞쪽 뒤쪽에 원소를 추가/제거 가능
	- list는 노드 기반 컨테이너로 at(), [] 연산자 없음
	- 양방향 반복자를 제공, 원소를 탐색하려면 ++, --를 사용
	- 순차열 중간에 원소를 삽입, 제거하더라도 상수 시간 복잡도의 수행성능을 보임, 배열기반 컨테이너보다 빠름

---

### 7. 연관 컨테이너
* set 컨테이너
	- set 컨테이너는 key라 불리는 원소의 집합으로 이루어진 컨테이너이다
	- 모든 연관 컨테이너는 노드 기반 컨테이너이며 균형이진 트리로 구현
	- set은 컨테이너에 원소를 삽입하는 유일한 맴버함수 insert()를 제공
	- 연관 컨테이너는 정렬 기준이 있으므로 insert()에 의해 삽입된 원소는 자동 정렬된다
	- set 내의 모든 원소는 유일하다
	- 원소 중복을 원하면 multiset를 이용
	- 연관 컨테이너는 균형 이진 트리를 사용하므로 찾기 연산에 뛰어난 성능을 보인다

* multiset 컨테이너
	- multiset 컨테이너는 중복 원소를 컨테이너에 저장할 수 있다는 것 외에는 set과 동일

* map 컨테이너
	- map 컨테이너는 원소를 key와 value의 쌍으로 저장
	- set처럼 원소의 key는 컨테이너에 중복 저장될 수 없으며 중복 key를 저장해야 한다면 multimap을 이용
	- map은 set처럼 컨테이너에 원소를 삽입하는 유일한 멤버함수 insert()를 제공
	- at(), [] 연산자 제공, 다른 연관 컨테이너들은 없음

* multimap 컨테이너
	- multimap 컨테이너는 중복 key를 컨테이너에 저장할 수 있다는 것 외에는 map과 동일

---

### 11. 컨테이너 어탭터
* 컨테이너 어뎁터
	- 컨테이너 어뎁터는 다른 컨테이너의 인터페이스를 변경한 컨테이너
	- STL에는 stack, queue, priority_queue 세 가지 컨테이너 어뎁터가 있다

* stack 컨테이너

* queue 컨테이너

* priority queue 컨테이너
	- priority queue와 set의 차이
		1. priority queue는 오직 pop하는 값만 알 수 있지만 set은 다른 원소들에 접근이 가능

---

### 12. string 컨테이너
* string 컨테이너
	- string 컨테이너는 문자만을 원소로 저장하고 문자열을 조작할 목적으로 만들어진 컨테이너
	- 시퀀스 컨테이너며 배열 기반 컨테이너
	- string은 임의접근 반복자를 지원
	- vector처럼 메모리 공간을 reserve()하고 사용할 수 있으며, capacity()로 할당된 메모리 공간을 확인할 수 있다
