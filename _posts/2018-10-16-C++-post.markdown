---
layout: post
title:  "C++ 정리"
date:   2018-10-16 19:51:02 +0900
---

# 1. C++ 시작
## 1.1 컴퓨터와 프로그래밍
- 프로그래밍과 프로그래밍 언어
	- 프로그램 : 컴퓨터가 처리할 일련의 작업을 묘사하는 것

	- 프로그래밍 언어 : 이때 사용하는 컴퓨터 언어

	- 고급언어
		- 사람이 이해하고 표현하기 쉬움
		- 따라서 복잡한 알고리즘이나 프로그램 구조를 효율적으로 표현 가능

	- 어셈블리어
		- 기계어를 **상징적인 니모닉 기호(`ADD`, `SUB`, `MOVE`)로 일대일 대응** 시킨 언어
		- 기계어보다는 인간이 해석하기 쉬움

	- 기계어
		- **0과 1만의 이진수를 사용**하는 가장 원시적인 언어

	- 어셈블러
		- 어셈블리어를 기계어로 변환시키는 역할

	- 컴파일러
		- 고급 언어를 기계어로 변환시키는 역할

	- 고급언어->(**컴파일러**)->어셈블리어->(**어셈블러**)->기계어

## 1.2 표준 C++ 프로그램의 중요성
- ANSI(미국 국립 표준원)에서 C++에 대한 표준을 정함

- 표준의 중요성
	- ANSI 표준으로 작성된 C++ 프로그램 소스는 
	- 모든 플랫폼, C++ 컴파일러에 의해 컴파일 가능해야 함
	- 동일한 실행 결과를 보장

## 1.3 C++ 언어의 특징
- C++ 언어의 주요한 설계 목표
	- C언어와 **호환성**

	- 객체 지향 개념 도입
		- 데이터 캡슐화
		- 상속
		- 다형성

	- 엄격한 타입 체크
		- 런타임 오류 가능성을 감소
		- 디버깅을 도움

	- 런타임 효율성 저하를 최소화(인라인 함수)

- C++에 새롭게 추가된 기능
	- 인라인 함수
		- **자주 호출되는 함수**를 호출되는 지점에 바로 삽입하여 실행 시간을 감소

	- 함수 오버로딩(Function overloading)
		- 함수이름은 동일하고
		- 매개 변수의 개수나 타입이 다른 함수들을 선언

	- 디폴트 매개 변수
		- 매개 변수에 값을 넣지않는 경우 기본적으로 입력되는 값을 설정 가능

	- 참조와 참조 변수
		- 변수에 별명을 붙여 변수 공간을 같이 사용

	- 참조에 의한 호출
		- 함수 호출 시 참조를 전달 가능

	- `new`와 `delete`연산자
		- 동적 메모리 할당, 해제를 위한 `new`, `delete` 연산자를 도입

	- 연산자 재정의(operator overloading)
		- 기존의 연산자에 **새로운 연산을 정의**할 수 있다

	- 제네릭 함수와 클래스 
		- 함수나 클래스를 **데이터 타입에 의존하지 않고 일반화**시킬 수 있게 한다

- C++의 객체 지향 특성
	- 객체와 캡슐화
		- 캡슐화는 **클래스**로 구분
		- 클래스의 구성
			- 멤버변수
			- 멤버함수

	- 상속성
		- 자식 클래스의 객체가 생성될 때 부모 클래스의 멤버를 가지고 생성됨
		- 재사용성을 높임

	- 다형성
		- 하나의 기능이 경우에 따라 다르게 작동
		- 연산자 중복
		- 함수 오버로딩(함수 중복)
		- 함수 오버라이딩(함수 재정의) 등

- C++에서 객체 지향을 도입한 목적
	- 소프트웨어 생산성 향상
	- 실세계에 대한 쉬운 모델링
		- 각 요소를 **객체로 정의**하고
		- 객체의 **속성과 행위를 묘사**하고
		- 객체 사이의 **상호작용을 표현**하는 방법이 더 효과적

- C++의 약점
	- 캡슐화 원칙이 무너짐
		- C언어와의 호환성 때문에 **전역변수 허용**

## 1.4 C++ 프로그램 개발 과정
- C++ 소스 작성 -> 컴파일 -> 링킹 -> 실행파일 생성

- 컴파일
	- 컴파일러는 컴파일 전에 전처리기를 실행 
		- `#include`문을 실행하여 헤더파일의 텍스트를 소스에 추가
	- 컴파일러는 소스 프로그램이 문법에 맞게 작성되었는지 검사
	- 기계어 코드로 변환하여 **목적 파일을 생성**

- 링킹
	- 생성된 목적파일을 필요한 라이브러리나 다른 소스와 연결하여
	- 하나의 **실행 파일로 만드는 작업**
	
- 빌드 : 컴파일과 링킹을 모두 시행하여 실행파일을 만드는 일련의 과정

---

# 2. C++ 프로그래밍의 기본
## 2.1 C++ 프로그램의 기본 요소와 화면 출력
```c++
#include <iostream>

int main(){	// ANSI C++ 표준의 main() 반환 타입은 int
	std::cout << "Hello\n";
	std::cout << "첫 번째 맛보기입니다.";
	return 0;	// ANSI C++ 표준에서 main()의 리턴 생략 가능
}
```
- `main()`함수
	- c++ 프로그램의 실행 시작점
	- 반드시 하나의 `main()` 함수가 존재
	- `main()` 함수가 종료되면 프로그램이 종료

- #include <iostream>
	- **C++ 표준 입출력**을 위한 클래스 객체가 선언
	- `cout` 객체, `<<` 연산자 등이 iostream 라이브러리에 포함

- 화면 출력
	- `cout` 객체
		- 스크린 장치와 연결된 **C++ 표준 출력 스트림 객체**
		- C++ 프로그램에서 출력한 데이터를 `cout`과 연결된 스크린에 출력하는 역할

	- `<<` 연산자
		- 스트림 삽입 연산자
		- 오른쪽 피연산자 데이터를 **왼쪽 스트림 객체에 삽입**하는 역할
		- `<<` 연산자는 원래 정수를 **왼쪽으로 시프트**하는 기본연산자
		- iostream에서 출력 스트림에 데이터를 삽입하는 연산자로 **연산자 재정의**(operator overloading)됨

	- `<<` 연산자는 문자열뿐만아니라 다른 **기본 타입 데이터도 출력가능**
		- `bool`, `char`, `short`, `int`, `long`, `float`, `double`
	
	- `<<` 연산자의 피연산자에 **식이나 함수 호출문 입력 가능**
		```c++
		std::cout << "n + 5 = " << n + 5;	// 식 입력
		std::cout << f();					// 함수 호출
		```

	- 화면에서 다음 줄로 넘어가기
		```c++
		std::cout << "Hello" << "\n";	// '\n' 사용하여 줄 넘기기
		std::cout << "Hello" << endl;	// endl 조작자로 줄 넘기기
		```

	- `\n`과 `endl`의 차이
		- `\n`를 사용하면 `\n` 문자를 cout의 스트림 버퍼에 삽입만한다.
		- `endl`는 iostream에 작성되어 있는 함수
		- `<<` 연산자가 `endl()` 함수를 호출하면 `endl`는 `\n`을 cout의 스트림 버퍼에 넣고 
		- 현재 스트림 버퍼에 있는 데이터를 즉각 장치에 출력하도록 지시한다.
		- `endl`을 실행할 때마다 flush를 하므로 `\n`보다 **속도가 느리다**

## 2.2 namespace와 std::
- `namespace`의 목적
	- 프로그래밍 중 **클래스, 함수, 변수 등의 이름이 충돌하는 경우를 방지**하기 위해
	- 다른 `namespace`에 선언된 동일한 이름들은 다른 것으로 인식

- namespace 생성 방법
	```c++
	namespace sejin{	// sejin이라는 namespace 생성
		// 이 곳에 선언되는 모든 이름은 sejin namespace에 생성된 이름
	}
	```
	- namespace 키워드를 쓰고 중괄호로 묶는다.

- namespace 사용 방법
	```c
	namespace::identifier
	sejin::getScore();
	```

- ANSI C++ 표준에서 지원되는 **모든 라이브러리는 `std` 이름 공간 안에 구현**

## 2.3 키 입력 받기
- cin 예제
	```c++
	#include <iostream>
	using namespace std;

	int main(){
		cout << "너비를 입력하세요>>";

		int width;
		cin >> width;

		cout << "높이를 입력하세요>>";

		int height;
		cin >> height;

		int area = width * height;
		cout << "면적" << area << "\n";
	}
	```

- **표준 입력 스트림 객체 `cin`과 `>>` 연산자를 사용**하여 사용자로부터 키를 입력받음

- **모든 기본 타입**에 대해 >> 연산자로 데이터 입력이 가능
	- `bool`, `char`, `short`, `int`, `long`, `float`, `double`

- `scanf`와 다른점
	```c++
	int width;
	cin >> width;	// cin는 입력받는 변수의 이름을 사용
	cin >> &width;	// 에러
	scanf("%d", &width);	// scanf는 입력받는 변수의 주소를 사용
	```

- 여러개의 값을 입력받는 방법
	```c++
	cout << "너비와 높이를 입력하세요>>";
	cin >> width >> height;
	cout << width << '\n' << height << '\n';
	```
	- `cin`은 여러개의 >> 연산자를 사용하여 **여러 값을 입력받을 수 있음**

- `cin` 객체
	- 키보드와 C++ 응용프로그램을 연결하는 C++ 표준 입력 스트림 객체
	- 키보드로 입력되는 모든 값은 **`cin` 객체의 스트림 버퍼로 들어감**
	- 응용프로그램은 `cin` 객체에서 입력된 값을 읽는다

- `>>` 연산자
	- 왼쪽 피연산자인 **스트림 객체로부터 데이터를 읽음**
	- 오른쪽 피연산자에 **지정된 변수에 삽입**

- Enter 키를 누를 때 변수에 키 값이 전달
	- cin과 >> 연산자는 Enter 키가 입력될 때 사용자의 키 입력이 끝났다고 인식
	- 입력한 키들은 일차적으로 cin의 스트림 버퍼에 저장
	- Enter를 누르면 그 후에 >> 연산자가 cin의 입력 버퍼에서 입력된 값을 차례로 변수에 저장
	- 입력 도중에 backspace를 누르면 cin의 스트림 버퍼에 저장된 값이 제거

- C++는 실행문 중간에 변수 선언 가능
	- C언어는 반드시 실행문 전에 변수 선언해야 함

## 2.4 키보드로 문자열 입력
- 문자열은 C++의 **기본 데이터 타입이 아님**

- 문자열 표현방법
	- C-스트링 : C언어에서 문자열을 표현하는 방법
	- string클래스 : 문자열을 객체로 다루는 방법(권장)

- 첫 번째 방법 : C-스트링
	- 널문자(`\0`)로 끝나는 `char` 배열
	- C언어에서 사용하는 문자열 방식
		```c++
		char name1[6] = {'G', 'r', 'a', 'c', 'e', '\0'}; // 문자열 "Grace"
		char name2[5] = {'G', 'r', 'a', 'c', 'e'}; // 문자열이 아님. 단순 문자 배열
		```
	- 문자열 리터럴을 직접 배열에 저장하는 방식으로도 문자열 초기화 가능
		```c++
		char name3[6] = "Grace";
		char name4[] = "Grace";	// name4 배열의 크기는 6으로 자동설정
		```
		- 문자열 마지막에 `\0`을 추가하기 위해 배열의 크기는 문자수보다 최소한 1이상 커야한다.
			```c++
			char name5[10] = "Grace";	// 남는 배열요소는 `\0`으로 초기화
			```

	- cin을 이용한 문자열 입력
		```c++
		char name[6]; // 5개의 문자로 구성된 문자열을 저장할 수 있는 char 배열
		cin >> name; // 표준 입력 스트림에서 문자열을 읽어 name배열에 저장
		```	
		- 6개 이상의 문자를 입력하면 배열의 크기를 초과
		- 런타임 에러가 발생

	- `cin`과 `>>` 연산자로 문자열을 입력받을 때의 허점
		- `>>` 연산자는 **공백문자를 만나면 문자열을 종료**한다.
			```c++
			이름을 입력하세요>>마 이 클 // 빈칸을 만나면 문자열 입력 종료
			이름은 마입니다.
			```
			- '이 클'은 다음 `>>` 연산자가 나올때까지 스트림에 대기
	
	- `cin.getline()`을 이용한 문자열 입력
		- cin 객체의 getline() 맴버함수를 이용
		- 공백이 포함된 문자열을 입력받을 수 있음
		- cin.getline(char buf[], int size, char delimitChar)
			- buf : 입력받은 문자열을 저장할 배열
			- size : buf 배열의 크기(최대 size-1 길이만큼 저장가능)
			- delimitChar : 문자열 입력 끝을 지정하는 구분 문자
		- delimitChar로 지정된 문자는 저장되지 않고 cin의 버퍼에서도 사라짐
		- buf 배열의 마지막에는 널문자 저장
		```c++
		#include <iostream>
		using namespace std;

		int main(){
			cout << "주소를 입력하세요:";
			char address[100];
			cin.getline(address, 100, '\n');

			cout << "주소는 " << address << "입니다.\n";
			return 0;
		}
		```

- 두 번째 방법 : string 클래스
	- C++ 표준 라이브러리에서 제공하는 string 클래스 사용하는 방법
	- string 클래스는 **문자열의 크기에 제약이 없음**
---

### 3. 클래스와 객체
* 객체에 대한 이해
	- 캡슐화  : 객체의 구성요소들을 캡슐로 싸서 보호하고 볼 수 없게 하는 것
	- 객체의 일부 요소는 공개된다 : 객체들이 서로 통신하기 위해 일부 요소는 노출
	- 객체는 맴버 변수와 맴버 함수로 구성

* c++ 클래스 만들기
	- 맴버 변수는 클래스 선언부에서 초기화 될 수 없다
	- 접근 지정자
		1. public, private(디폴트), protected

* 객체 생성과 객체 활용
	- 객체 생성 : 클래스 이름 + 객체 이름
		1. 예 : Circle donut;
	- 객체의 맴버 접근
		1. 객체 이름 뒤에 .을 찍고 뒤에 맴버를 쓴다
		2. 예 : 객체이름.맴버

* 생성자
	-	클래스는 객체가 생성될 때 자동으로 실행되는 생성자라는 특별한 맴버 함수를 통해 객체를 초기화
		1. 생성자의 목적은 객체가 생성될 때 초기 작업을 위해
		2. 오직 한번만 실행
		3. 생성자 함수의 이름은 클래스 이름과 동일하게 작성
		4. 생성자 함수의 리턴 타입은 선언하지 않는다
		5. 생성자는 중복가능

* 소멸자
	- 소멸자는 객체가 소멸되는 시점에서 자동으로 호출되는 클래스의 맴버 함수
	- 객체 소멸 시 소멸자 함수가 반드시 실행된다
		1. 객체가 사라질 때 필요한 마무리 작업을 하기 위해서
		2. 소멸자의 이름은 클래스 이름 앞에 ~를 붙인다
		3. 소멸자는 리턴 타입이 없으며 어떤 값도 리턴해서는 안된다
		4. 소멸자는 오직 한개만 존재, 매개변수를 가지지 않는다
		5. 소멸자가 없을 시에 기본 소멸자가 자동 생성

	- main() 스택에 pop 되는 순으로 소멸자 실행(나중에 호출된 함수가 제일 먼저 소멸자 실행)

* 접근 지정
	- 접근 지정자
		1. private : 클래스 내의 맴버 함수에만 공개
		2. protected : 클래스 내의 맴버와 상속받은 파생 클래스에만 허용
		3. public : 클래스 내외의 모든 함수에게 공개

	- 클래스 외부에서 객체를 생성하기 위해서는 생성자를 public으로 선언해야 한다

* 인라인 함수
	- 짧은 코드로 구성된 함수에 대해, 함수 호출 오버헤드로 인한 프로그램의 실행 속도 저하를 막기 위해 도입된 방법
	- 컴파일러는 인라인 함수를 호출하는 곳에 인라인 함수의 코드를 그대로 삽입하여 함수 호출이 일어나지 않게 한다
	- 생성자를 포함하여 클래스의 모든 멤버 함수가 인라인을 선언 가능

---

### 4. 객체 포인터와 객체 배열, 객체의 동적 생성
* 객체 포인터
	- 객체 이름으로 맴버를 접근할 때는 점(.) 연산자 사용
	- 객체 포인터로 맴버를 접근할 때는 -> 연산자 사용

* 객체 배열
	- 기본 타입의 배열 선언과 동일
	- 객체 배열 선언 시 오직 매개 변수 없는 기본 생성자를 호출
	- 객체 배열이 소멸 시, 높은 인덱스에서부터 원소 객체가 소멸되고, 각 객체마다 소멸자가 실행
	- 객체 배열을 생성할 때 {} 안에 매개 변수가 있는 생성자를 사용하여 생성할 수 있다
	-	예: Circle circleArray[3] = {circle(10), circle(20), circle()};

* 동적메모리 할당 및 반환
	- new 연산자 : 힙 시스템 공간에서 데이터타입의 크기만큼 메모리를 할당받고 주소를 리턴
	- delete 연산자 : 할당 받은 메모리를 힙으로 반환(동적할당 받은 메모리만)
	- int * pInt = new int; : int 타입의 정수공간 할당
	- circle * pCircle = new Circle(); : circle 클래스 타입의 객체 할당

* 배열의 동적 할당 및 반환
	- 데이터 타입 * 포인터변수명 = new 데이터 타입 [배열길이];
	- delete [] 포인터변수명
	- new로 배열을 동적 할당 받을 때 초기값 지정 불가

* 객체의 동적 생성 및 반환
	- 클래스 이름 * 포인터명 = new 클래스이름(생성자매개변수);
	- delete가 실행되면 객체 반환전에 객체의 소멸자 실행

* this 포인터
	- 객체 자신에 대한 포인터로 클래스의 맴버 함수 내에서만 사용
	- this 포인터가 필요한 경우
		1. 맴버 변수의 이름으로 매개변수를 만들 경우
		2. 클래스의 맴버 함수에서 객체자신의 주소를 리턴하고 싶은 경우

---

### 5. 함수와 참조, 복사 생성자
* 참조
	- 값에 의한 호출 : 실인자 값이 매개 변수에 복사되어 전달되는 방식
	- 주소에 의한 호출 : 포인터로 실인자가 연결되어 주소를 직접 포인터 타입의 매개 변수에 전달받는 방식
	- 참조에 의한 호출 : 이미 선언된 변수에 대한 별명, 참조자(&)를 이용하여 선언
		1. 예 : Circle circle;	Circle &refc = circle;
	- 참조 변수는 포인터가 아니므로 -> 연산자 사용못함
	- 참조 변수에 대한 참조 선언 가능

* 복사 생성자
	- 얕은 복사 생성자의 문제점
		1. 포인터 타입의 맴버 변수가 없는 클래스의 경우 문제 없다
		2. 그러나 클래스가 포인터 맴버 변수를 가지고 있는 경우, 원복 객체의 포인터 맴버 변수가 사본 객체의 포인터 맴버 변수에 복사되면 둘은 같은 메모리를 가리키게 되어 문제가 발생

---

### 6. 함수 중복과 static 멤버
* 함수 중복
	- 같은 이름의 함수를 여려개 만들 수 있다
	- 중복 함수 조건
		1. 함수의 이름이 동일
		2. 매개 변수 타입이나 매개 변수 개수가 다르다
		3. 리턴타입은 함수 중복 조건에 없다(리턴 타입만 다른 함수는 함수 중복 아니다)
	- 소멸자는 원래 클래스 당 1개이므로 소멸자 함수 중복 불가능

* 디폴트 매개 변수
	- 예 : void star(int a=5);
	- 매개 변수 없이 함수 호출시 자동을 디폴트 매개변수가 입력

* 함수 중복의 모호성
	- 형 변환으로 인한 모호성
		1. float square(float a);
		2. double square(double a);
		3. square(3) 은 어떤것을 실행할지 모른다
	- 참조 매개 변수로 인한 모호성
		1. int add(int a, int b);
		2. ind add(int a, int &b);
	- 디폴트 매개 변수로 인한 모호성
		1. void msg(int id);
		2. void msg(int id, string s="")
		3. msg(6)은 어느 것을 호출할지 모른다

---


### 8. 상속
* 상속의 개념
	- 객체 지향 언어에서 상속은 부모 유전자를 자식이 물려받는 유전적 상속과 유사
	- 이미 만들어진 클래스의 맴버들을 물려받게 함으로써 코드의 중복작성을 없애고 코드 작성에 드는 시간과 비용을 줄인다

* 상속의 목적과 개념
	- 간결한 클래스 작성 : 클래스들 사이의 중복을 제거
	- 클래스간의 계층적 분류 및 관리의 용이함
	- 클래스 재사용과 확장을 통한 소프트웨어 생산성 향상

* 클래스 상속과 객체
	- 상속은 class 선언 뒤에, 콜론과 기본 클래스 이름을 선언, 이때 기본 클래스 이름 앞에 반드시 상속 접근을 지정한다
	- 상속 횟수는 제한 없다
	- 파생 클래스 객체는 기본 클래스의 맴버와 파생 클래스의 맴버를 모두 가진다
	- 파생 클래스는 상속을 통해 기본 클래스 멤버를 자신의 맴버로 확장
		1. 파생클래스의 멤버들은 기본 클래스의 private 맴버 외에 모든 멤버를 접근 가능
		2. 기본클래스의 private 맴버는 기본클래스 내의 맴버에서만 접근 가능

* protected 접근 지정
	- 기본 클래스에 protected로 지정된 맴버는 파생 클래스에게 접근을 허용하고 다른 클래스나 외부함수에서 접근 불가능

* 상속과 생성자, 소멸자
	- 파생 클래스 객체가 생성될 때 파생클래스생성자와 기본 클래스 생성자 모두 실행
	- 기본 클래스 생성자 먼저 실행
	- 소멸자는 생성자 순서 반대로
	- 파생클래스의 생성자에 대해 함께 실행될 기본 클래스의 생성자를 명시적으로 지정하지 않으면, 컴파일러는 묵시적으로 기본 클래스의 기본 생성자를 실행(파생클래스 생성자에 매개변수가 있다고 해도 기본 클래스의 기본생성자 실행)

* 다중 상속
	- 하나의 파생 클래스가 여러 클래스를 동시에 상속 받는 것

* 가상 상속
	- 다중 상속의 문제점
		1. 다중 상속된 파생클래스가 객체를 생성할때 같은 맴버변수가 중복되어 생성된다
		2. 중복된 변수를 구분할 수 없으므로 컴파일러는 오류를 낸다

	- 파생클래스를 선언할때 기본 클래스 앞에 virtual 키워드를 사용하여 가상 상속을 선언하여 문제를 해결
	- virtual은 기본 클래스의 맴버 공간을 오직 한번만 할당


---


### 9. 가상 함수와 추상 클래스
* 상속 관계에서의 함수 중복
	- 오버로딩을 통해 기본 클래스의 함수와 동일한 함수를 파생클래스에 선언할 수 있다

* 가상 함수와 오버라이딩
	- 가상함수와 오버라이딩은 상속에 기반을 둔 기술로 객체 지향의 꽃이다
	- 오버라이딩은 파생 클래스에서 기본 클래스에 작성된 함수를 중복 작성하여
	- 기본 클래스에 작성된 가상 함수를 무력화시키고, 객체의 주인 노릇을 하는 것이다
	- 기본 클래스의 포인터를 쓰던 파생 클래스의 포인터를 쓰던 가상함수를 호출하면 파생클래스에 오버라이딩된 함수가 실행
	- 가상 함수란 virtual 키워드로 선언된 맴버 함수
	- 파생 클래스에서 기본 클래스의 가상함수와 완전히 동일한 원형의 함수를 재정의 하는 것을 오버라이딩이라고 한다
	- 함수 오버로딩은 객체 안에 같은 함수가 두개 존재하고 두개 모두 호출 가능, 함수 오버라이딩은 두개의 함수가 존재하지만 하나는 죽고 항상 나머지 하나가 호출됨
	- 업캐스팅된 기본클래스 타입의 포인터로 기본클래스의 가상 맴버 함수를 호출해도 자동으로 동적 바인딩되어 오버라이딩된 파생클래스의 맴버함수가 호출된다

* 오버라이딩의 목적
	- 기본 클래스에 가상함수를 만드는 목적은 파생클래스들이 자신의 목적에 맞게 가상함수를 재정의 하도록 하는 것
	- 가상함수는 하나의 인터페이스에 대해 서로 다른 모양의 구현이라는 객체 지향 언어의 다형성을 실현하는 도구

* **동적 바인딩**
	- 가상 함수를 호출하는 코드를 컴파일할 때, 컴파일러는 바인딩을 실행 시간에 결정하도록 미룬다
	- 나중에 가상함수가 호출되면, 실행 중에 객체 내에 오버라이딩된 가상 함수를 동적으로 찾아 호출
	- 이 과정을 동적 바인딩이라고 한다
	- 기본 클래스의 객체에 대해서는 가상함수가 호출된다고 해도 동적바인딩이 일어나지 않는다
	- 파생 클래스의 객체에 대해, 기본 클래스의 포인터로 가상함수가 호출될 때 일어난다
		1. 기본 클래스 내의 맴버함수가 가상 함수 호출
		2. 파생 클래스 내의 맴버함수가 가상 함수 호출
		3. 외부 함수에서 기본클래스의 포인터로 가상함수 호출
		4. 다른 클래스에서 가상함수 호출

* C++ 오버라이딩의 특징
	- 가상함수의 이름과 매개변수 타입, 개수뿐아니라 리턴 타입도 일치해야 오버라이딩이 성공한다
	- 파생 클래스에서 virtual 키워드를 생략해도 자동으로 가상 함수가 된다

* 오버라이딩과 범위 지정 연산자(::)
	- 범위 지정연산자(::)를 이용하여 기본 클래스의 가상함수를 호출할 수 있다
	- 가상함수 정적바인딩이다

* 가상 소멸자
	- 기본 클래스의 소멸자를 만들 때 가상 함수로 작성할 것을 권한다
	- 파생클래스의 객체가 기본 클래스에 대한 포인터로 delete되는 상황에서 정상적인 소멸이 되도록하기 위해서
	- Base * p = new Derived();
	  delete p;
	- p가 Base 타입이므로 컴파일러는 ~Base() 소멸자를 호출하도록 컴파일한다 그러므로 ~Base()만 실행되고 ~Derived()는 실행되지 않는다

* 가상 함수와 오버라이딩의 활용 사례
	- 가상 함수는 파생 클래스에서 재정의할 함수를 알려주는 인터페이스의 역할을 한다
		1. 가상함수를 가진 기본 클래스의 목적
		2. 가상 함수 오버라이딩
		3. 동적 바인딩 실행
		4. 기본 클래스의 포인터 활용

* 추상 클래스
	- 순수 가상함수
		1. 기본 클래스에 작성된 가상함수는 실행할 목적보다는 파생 클래스에서 재정의하여 구현할 함수를 알려주는 인터페이스역할이다
		2. 파생클래스에서 가상함수를 재정의 하면, 동적 바인딩에 의해 기본 클래스의 가상함수는 거의 실행되지 않는다
		3. 순수 가상함수는 함수의 코드가 없고 선언만 있는 가상함수
		4. 순수 가상 함수는 맴버 함수의 원형 뒤에 =0;으로 선언

	- 추상 클래스
		1. 최소 하나의 순수 가상 함수를 가진 클래스를 추상 클래스라고 한다
		2. 추상 클래스는 실행 코드가 없는 순수 가상함수를 가지고 있기 때문에 불완전한 클래스이다.
		3. 그러므로 응용프로그램에서 추상 클래스의 인스턴스를 생성할 수 없다.
		4. 그러나 추상 클래스에 대한 포인터 선언은 문제 되지 않는다.

	- 추상 클래스의 목적
		1. 인스턴스를 생성할 목적이 아니라, 상속을 위한 기본 클래스로 활용하는 것이 목적

	- 추상 클래스를 상속받는 파생 클래스는 자동으로 추상 클래스가 된다
		1. 그래서 파생클래스에 순수 가상함수를 오버라이딩하지 않으면 인스턴스를 생성할 수 없다

	- 추상 클래스의 구현
		1. 파생 클래스가 온전한 클래스가 되려면 상속받은 추상 클래스의 모든 순수 가상함수를 오버라이딩하여 구현하여야 한다
		2. 그럼 파생 클래스는 인스턴스를 생성할 수 있다


---


### 10. 템플릿과 STL
* 일반화와 템플릿
	- 함수중복으로 다른부분은 모두 같고 매개변수 타입만 다른 함수들을 구현한다면 관리가 번거롭고 프로그램 길이도 증가
	- 템플릿 : 매개 변수 타입만 다른 중복된 함수들을 일반화 시킨 틀
	- template 키워드를 이용하면 중복 함수들을 일반화시킨 특별한 함수를 만들 수 있다
	- 이를 템플릿 함수 혹은 제네릭 함수라고 한다
	- 예시
		template <class T>
		void myswap (T &a, T &b){

		}
	- 템플릿으로부터 구체화
		1. int a=4, b=5; myswap(a,b);
		2. 컴파일러는 myswap(a,b); 호출문을 컴파일할 때 myswap()함수를 찾는다
		3. 템플릿으로 선언된 myswap() 함수를 발견
		4. 구체화한다. myswap(a,b);의 함수 호출문에서 실인자 a, b가 모두 int타입이므로, 템플릿의 제네릭 타입T에 int를 대입시켜 myswap(int &a, int &b)의 소스 코드를 만든다
		5. 구체화된 함수의 코드를 컴파일하고, 이함수를 호출한다
	- 클래스 타입도 템플릿의 타입매개변수로 가능
	- 구체화 오류
		1. myswap함수의 매개 변수는 모두 T타입으로 선언되어 있기 때문에, 템플릿 함수를 호출할 때 매개 변수들의 타입은 모두 같아야 한다
	- 템플릿의 장단점
		1. 함수의 작성의 용이
		2. 함수 코드의 재사용성을 높인다
		3. 생산성과 유연성을 높인다
		4. 템플릿 관련 컴파일 오류 메시지가 빈약하여 디버깅에 어려움이 있다

* 다양한 제네릭 함수 만들기
	- 두 개 이상의 제네릭 타입을 가진 경우도 가능
	- template <class T1, class T2>
		void mcopy(T1 src [], T2 dest [], int n)
	- src [] 타입은 T1, dest [] 타입은 T2로 서로 다르다. 그러므로 mcopy() 호출 시, 두 매개 변수에 동일한 타입의 배열을 넘길 수도 있고, 다른 타입의 배열을 넘길 수도 있다
	- 템플릿 함수와 이름이 동일한 함수가 중복되어 있을 때, 컴파일러는 중복된 함수를 템플릿 함수보다 우선하여 바인딩한다
	- 템플릿 함수선언에 디폴트 매개변수 사용 가능
	- 예시 : template <class T1, class T2>
					void mcopy(T1 src [], T2 dest [], int n = 5){}


---


### 11. C++ 입출력 시스템
* C++ 입출력 기초
	- 스트림 : 연속적인 데이터의 흐름 혹은 데이터를 전송하는 소프트웨어 모듈
	- 스트림은 **프로그램과 장치를 연결**하며 **바이트 단위**로 입출력한다
	- C++ 응용프로그램은 출력 장치에 직접 출력하는 대신 출력 스트림에 출력하고, 입력 장치로부터 직접 입력받는 대신, 입력 스트림으로부터 입력받는다
	- c++ 입출력 스트림의 중요한 특징은 **스트림이 버퍼를 가진다**
		1. 입력스트림 버퍼 : 입력된 데이터를 프로그램에 전달하기 전에 일시 저장하는 공간
		2. 출력스트림 버퍼 : 출력 장치로 보내기 전에 데이터를 일시 저장하는 공간
		3. 키 입력 스트림 버퍼 : 엔터키 입력이 들어오기 전까지 그동안 입력된 문제들이 입력 스트립 버퍼에 저장된다
		4. 스크린 출력 스트림 버퍼 : C++ 프로그램이 문자열을 출력하면 일단 출력 스트림 버퍼에 저장된 후, '\n'이 도착하거나 버퍼가 꽉차면 출력한다
		5. 버퍼의 필요성
			- 파일 출력의 경우에 버퍼가 있다면, 쓰기가 이루어진 데이터를 스트림 버퍼에 모아 두었다가, 한번에 운영체제 API를 호출하여 파일에 쓰면 운영체제와 장치를 구동하는 횟수가 줄어든다
			- 키 입력 스트림의 경우, 사용자가 입력한 키를 우선 버퍼에 저장하고, 프로그램에게 전달하기 전에 수정할 수 있다.
	- C++ 표준은 오직 **스트림 입출력만 지원**
		1. **스트림 입출력을 이용하여 작성된 C++ 프로그램은 어떤 컴파일러, 플랫폼과도 호환**되지만, 특정 컴파일러에 종속된 저수준 입출력 방식을 사용하는 C++ 프로그램은 다른 컴파일러에서 컴파일되지 않는다.
	- 구 표준과 새 표준의 C++ 입출력 라이브러리
		1. 구 버전 입출력 시스템은 **영어와 같은 문자 하나를 한 바이트로 표현**하는 언어의 문장만 입출력하도록 설정
		2. 문자 하나가 **2바이트인 한글 문자**를 입력할 수 없음
		3. cin으로 2바이트로 구성되는 문자를 읽는 방법은 없음(배열을 이용해서 char ch[3] 공간에 저장해야 한다 배열의 마지막 공간은 \0)
		4. 구 표준의 C++ 입출력 라이브러리 : **ios, istream, ostream, iostream, ifstream, ofstream, fstream**
		5. ANSI/ISO C++ 표준위에서는 **탬플릿을 사용하여, C++ 입출력 라이브러리를 일반화 시킴**
		6. 새 표준의 C++ 입출력 라이브러리 : **basic_ios, basic_istream, basic_ostream, basic_iostream, basic_ifstream, basic_ofstream, basic_fstream**
	- C++ 표준 입출력 스트림 객체
		1. <iostream> 헤더 파일을 include한 C++ 프로그램이 실행되기 시작하면, cin, cout, cerr 등 표준 입출력 스트림 객체가 생성
		2. C++ 프로그램에서 바로 이들을 사용할 수 있음
		3. cin : **키보드 장치**와 연결된 istream 타입의 표준 입력 스트림 객체
		4. cout : **스크린 장치**와 연결된 ostream 타입의 표준 출력 스트림 객체
		5. cerr와 clog : cerr와 clog 객체는 둘 다 **표준 오류 출력 스트림 객체**, clog는 버퍼를 거치지만 cerr는 버퍼를 거치지 않고 스크린에 오류 메시지 출력

* ostream의 맴버 함수를 이용한 문자 출력
	- ostream 클래스는 << 연산자 외에 화면 출력을 위한 다른 맴버 함수를 제공
	- put()
		1. ostream& put(char ch)
		2. put()은 **문자 단위로 출력하는 함수** ex) cout.put('A'); cout.put(65); 모두 A출력
		3. **put() 함수는 ostream&를 리턴하므로 put을 연결하여 사용가능** ex) cout.put('A').put('b').put('R');
	- write()
		1. ostream& write(char* str, int n)
		2. write()는 **char 배열에 들어 있는 문자들을 출력하는 함수**
		3. char str[] = "I love programming"; // char * str = "I love programming"; 과 동일
		4. cout.write(str, 6);  // str에 있는 6개의 문자 "I love" 출력
	- flush()
		1. ostream& flush()
		2. flush()는 **출력 버퍼에 있는 문자들을 모두 강제로 출력**

* istream의 멤버 함수를 이용한 문자 입력
	- istream 클래스도 >> 연산자 외에 다양한 입력 멤버 함수를 가짐
	- >> 연산자는 빈칸(Space 키), 탭(Tab 키), 뉴라인(Enter 키) 등 공백문자 키를 읽을 수 없지만, **istream의 멤버 함수를 사용하면 공백문자를 읽을 수 있음**
	- 문자 입력
		1. 문자를 입력받는 get() 함수는 2가지가 존재
		2. **2바이트로 구성되는 한글 문자는 읽을 수 없다**
	- **int** get()
		1. get()은 **입력 스트림**에서 **한 개의 문자를 읽어 리턴**
		2. **Enter 키 등의 공백 문자**도 읽어 리턴
	- istream& get(char& ch)
		1. get(char& ch) 함수는 문자를 읽어 **참조 매개 변수 ch에 저장하고 리턴**
		2. 공백문자 읽어 리턴 가능
	- 문자열 입력
		1. istream에는 문자열을 읽을 수 있는 get() 함수도 존재
		2. istream& get(char* s, int n)
		3. 입력 스트림으로부터 n-1개의 문자를 읽어 배열 s에 저장하고 마지막에 '\0' 문자 삽입. 입력 도중 '\n'을 만나면 '\0'을 삽입하고 리턴
		4. 입력 스트림에서 '\n' 문자를 만나면 읽기를 중단하고 리턴하므로, '\n'이 입력 스트림 버퍼에 남아있다
		5. 만일 이상태에서 다시 읽기를 하게 되면 입력 스트림에 있는 '\n'부터 읽기 시작하므로 아무것도 읽지 않고 바로 리턴한다
		6. 따라서 문자열을 읽은 후, 입력 스트림 버퍼에 남아있는 '\n' 문자를 제거해야 한다. cin.get(); 이나 cin.ignore(1); 사용
	- 한 줄 읽기
		1. istream& get(char* s, int n, char delim = '\n')
		2. 입력 스트림으로부터 최대 n-1개의 문자를 읽어 배열 s에 저장하고 마지막에 '\0' 문자 삽입. 입력 도중 delim에 지정된 구분문자를 만나면 지금까지 읽은 문자를 배열 s에 저장하고 리턴
		3. istream& getline(char* s, int n, char delim = '\n')
		4. get()과 동일. 하지만 delim에 지정된 구분 문자를 스트림에서 제거
		5. delim 매개 변수가 생략되면 Enter키가 입력될 때까지 한 라인을 읽는다
		6. getline()이 **delim문자를 스트림 버퍼에서 제거**하는 것과는 달리, get()은 **delim 문자를 버퍼에 그대로 남겨둔다**
	- 입력 스트림의 문자 건너 띄기
		1. istream& ignore(int n=1, int delim=EOF)
		2. 입력 스트림에서 n개 문자 제거. 도중에 delim 문자를 만나면 delim 문자를 제거하고 리턴

* 포맷 입출력
	- << 연산자나 cout의 put(), write() 멤버 함수는 **포맷 없이 데이터를 출력**
	- C++의 입출력 시스템은 다음 3가지 방법으로 포맷 입출력을 지원 : **포맷 플래그, 포맷 함수, 조작자**
	- 포맷 플래그
		1. C++ 입출력 스트림은 **32개의 포맷 플래그를 저장하는 멤버 변수**를 두고, 이를 참조하여 포맷 입출력한다
		2. 하나의 플래그는 한 비트로 표현되며 한 가지 포맷 정보를 표현한다
		3. long setf(long flags)
			- flags를 스트림의 포맷 플래그로 설정하고 이전 플래그를 리턴
		4. long unsetf(long flags)
			- flags에 설정된 비트 값에 따라 스트림의 포맷 플래그를 해제하고 이전 플래그를 리턴
	- 포맷 함수 활용
		1. ostream 클래스의 **멤버 함수 width(), fill(), precision()**은 각각 출력되는 필드의 너비, 유효 숫자 개수, 빈칸을 채우는 문자 등을 지정
		2. 필드의 최소 너비 설정, **width()**
			- int width(int minWidth) : 출력되는 필드의 최소 너비를 minWidth로 설정하고 이전에 설정된 너비 값 리턴
			- width()의 효과는 **호출 직후 하나의 필드에만 적용**되므로 주의
		3. 필드의 빈 공간 채우기, **fill()**
			- char fill(char cFill) : 필드의 빈칸을 cFill 문자로 채우도록 지정하고 이전 문자 값 리턴
			- 필드의 실제 크기가 width()에 의해 정의된 너비보다 작을 때, 남은 칸은 빈칸으로 채워진다. 하지만 **fill() 함수를 사용하면 빈칸을 문자로 채울 수 있다**
		4. 유효 숫자 자리수 지정, **precision()**
			- 출력 스트림은 숫자를 출력할 때 **유효 숫자 자리수를 디폴트로 6으로 설정**
			- precision() 멤버 함수를 호출하여 유효 숫자의 자리수를 변경 가능
			- int precision(int np)
			- 출력되는 수의 유효 숫자 자리수를 np개로 설정. **정수 부분과 소수점 이하의 수의 자리를 모두 포함**
			- 단 소수점(.)은 제외하고 자리수 계산
			- 소수점 마지막은 반올림
	- 조작자
		1. 조작자는 특별한 원형을 가진 함수로써, **매개 변수 없는 조작자**와 **매개 변수를 하나 가지는 조작자**로 나뉜다
		2. 매개 변수 없는 조작자
			- **iostream 헤더**를 include 해야 한다
			- endl, oct, dec, hex, left, right, fixed, scientific, flush, showbase, noshowbase, showpoint, noshowpoint, showpos, noshowpos, skipws, noskipws, boolalpha
		3. 매개 변수를 가지는 조작자
			- iomanip 헤더를 include 해야 한다
			- resetioflags(long flags), setbase(int base), setfill(char cFill), setioflags(long flags), setprecision(int np), setw(int minWidth)

* 삽입 연산자(<<)와 추출 연산자(>>)
	- 삽입 연산자의 중복
		1. 출력 스트림에 데이터를 출력하는 << 연산자를 **삽입 연산자 혹은 삽입자**라고 한다
		2. 본래 << 연산자는 **정수를 비트 단위로 시프트하는** C++의 기본 연산자이다
		3. C++ 입출력 시스템은 다양한 값을 출력할 수 있도록 **ostream 클래스에 << 연산자를 중복 작성**했다
	- 삽입 연산자의 실행 과정
		1. cout << 'a' << 123 << endl;
		2. 이 문장은 **객체, 입출력 스트림, 연산자 중복, 참조 매개 변수, 참조 리턴**이 절묘하게 연결되어 있는 환상적인 문장
		3. 리턴 타입이 의미하는 것
			- ostream 클래스 내에 중복 작성된 모든 << 연산자들은 ostream&를 리턴한다
			- ostream& operator << (char c);
			- << 연산자는 출력 스트림에 데이터를 삽입한 후, **출력 스트림 (*this)을 리턴**
			- 리턴 타입이 ostream&이므로 **스트림의 참조가 리턴된다**
			- 만일 리턴 타입이 ostream이라면 스트림의 복사본(*this)이 리턴되고, 그 다음에 실행되는 << 연산은 복사된 스트림에 출력하게 된다
			- 그렇기에 연속되는 두 << 연산이 서로 다른 출력 스트림에 출력하게 되므로 연속적인 << 연산자가 작동하지 않음
		4. 구체적인 실행과정
			- cout << 'a'에서 << 연산자 함수를 호출한다. 컴파일러는 **cout. << ('a')**로 변형하여 컴파일한다
			- 이 코드는 cout 객체 내의 연산자 함수 **operator<<(char c)를 호출하고** 'a'를 매개변수에 전달한다
			- operator<<(char c) 함수는 **문자 'a'를 현재 스트림(cout)의 버퍼에 저장**한다
			- *this 즉, 현재 스트림에 대한 참조를 리턴한다
			- 리턴되는 참조는 cout의 복사본이 아닌 **현재 스트림이 cout을 가리킨다**
			- << 123을 실행한다. 
			- 전에 cout << 'a'의 실행 결과 cout의 버퍼에 'a'가 삽입되고 cout에 대한 참조가 리턴되었다.
			- 그러므로 **<< 123은 cout << 123을 실행하는 것과 같고**, 'a'가 들어 있는 cout의 버퍼에 123을 출력하는 것이다.
			- 최종적으로 버퍼는 "a123"으로 변경되며, 적절한 시점에 화면에 출력된다
	- 추출 연산자의 중복
		1. cin과 함께 사용되는 **>> 연산자를 추출연산자**라고 부른다
		2. 연산자 >>는 cin으로부터 키를 입력받기도 하지만, 파일에서 읽을 때도 사용된다
		3. C++ 입출력 시스템은 입력 스트림으로부터 값을 입력받는 **다양한 >> 연산자를 istream 클래스에 중복작성**하였다

---


### 12. C++ 파일 입출력
* 텍스트 파일과 바이너리 파일
	- 파일은 **저장 매체에 저장되는 정보**이다
	- **바이트나 블록 단위**로 입출력된다
	- 기록되는 데이터의 종류에 따라 **텍스트 파일과 바이너리 파일**로 나뉜다
	- 텍스트 파일 : **오직 문자들만** 기록되는 파일
	- 바이너리 파일 : **문자뿐만 아니라 이미지 등** 다양한 정보가 기록된 파일
	- 텍스트 파일
		1. 사람들이 사용하는 글자 혹은 문자만으로 구성된 문서 파일
		2. 문서에는 글자 외의 그림, 동영상, 이미지, 색, 사운드 등을 포함하기는 하지만 **오직 글자로만 이루어진 문서 파일이 텍스트 파일**이다
		3. 텍스트 파일은 문자들로만 구성된 파일이므로, **ASCII코드나 유니코드로 작성된 문자 코드만** 텍스트 파일에 저장된다
		4. 예 : txt파일, HTML파일, XML파일, C++ 소스파일 등
	- 텍스트 파일 내부 보기
		1. 텍스트 파일은 문자들로만 구성된 파일이므로, 텍스트 파일에는 문자로 해석 가능한 코드 값들만 존재
		2. **만일 어떤 파일에 문자로 매핑할 수 없는 바이트가 있다면**, 그 파일은 텍스트 파일이 아니라 **바이너리 파일**이다.
	- 텍스트 파일과 Enter키
		1. 메모장과 같은 텍스트 편집기들은 사용자가 입력한 **Enter키를 '\r'과 '\n'**의 두 ASCII코드로 저장한다
		2. '\r' : carriage return 코드로 **커서를 현재 줄의 맨 앞으로 옮긴다**
		3. '\n' : line feed 코드로 커서를 **현재 있는 위치에서 한출 밑으로 옮긴다**
		4. 따라서 다음 줄의 맨 앞으로 넘어가려면 carriage return과 line feed가 모두 필요하다
	- 바이너리 파일
		1. **사진, 오디오, 그래픽, 컴파일된 코드** 등은 문자로 표현되지 않는 **바이너리 정보**들이다
		2. 바이너리 파일은 **문자**뿐만 아니라, 이런 **바이너리 정보**를 저장한다
		3. **텍스트 파일**의 각 바이트들은 **모두 문자로 해석**되지만
		4. **바이너리 파일**의 각 바이트는 **파일을 만든 응용프로그램만이 해석**할 수 있다
		5. jpeg, bmp 등의 이미지 파일, mp3 등의 오디오 파일, hwp, doc, ppt 등의 멀티미디어 문서 파일, **obj, exe** 등의 컴파일된 코드나 실행파일
	- 바이너리 파일 내부 보기
		1. 바이너리 파일에는 **문자로 해석할 수 없는** 바이너리 값들이 존재
	
* 파일 입출력 개요
	- C++ 파일 입출력 라이브러리
		1. ifstream : 파일 읽기 시에 사용
		2. ofstream : 파일 쓰기 시에 사용
		3. fstream : 하나의 파일에 읽기와 쓰기를 동시에 할 때 사용
	- 파일 입출력 스트림은 파일을 프로그램과 연결
		1. ifstream이나 ofstream은 **파일을 프로그램과 연결**하는 스트림
		2. ifstream 스트림 객체와 ofstream 스트림 객체가 파일을 연결하면, 
		3. get(), getline(), put(), read(), write() 등의 멤버함수들은 자연스럽게 스트림에서 연결된 파일에서 읽고 쓴다.
	- 파일 입출력 모드 : 텍스트 I/O와 바이너리 I/O
		1. C++ 파일 입출력 시스템은 파일을 읽고 쓰는 데이터를 문자로 국한한 **텍스트 I/O**
		2. 문자로 해석하지 않고 바이너리 값 그대로 읽고 쓰는 **바이너리 I/O**로 구분
	
* << 와 >> 연산자를 이용한 간단한 텍스트 파일 입출력
	- 파일 쓰기를 위한 스트림 객체 생성
		1. 텍스트 정보를 파일로 작성하기 위해서는, ofstream 클래스를 이용하여 파일 출력 스트림 객체를 생성한다
		2. ofstream fout; // 파일 출력 스트림 객체 생성
	- 파일 열기
		1. 텍스트 데이터를 파일에 쓰기 전에, 파일명을 매개 변수로 하고 fout 객체의 open()멤버 함수를 호출하여 **파일을 열어 출력 스트림에 연결**
		2. fout.open("song.txt"); // song.txt 파일 열기
		3. ofstream fout("song.txt") // 파일 출력 스트림 생성과 파일 열기 동시에 가능
	- << 연산자를 이용한 파일 쓰기
		1. int age = 21;
		2. char singer[] = "kim";
		3. char song[] = "Yesterday";
		4. fout << age << '\n'; // 파일에 21과 '\n'을 기록
		5. fout << singer << endl; // 파일에 "kim"과 '\n'을 덧붙여 기록
		6. fout << song << endl; // 파일에 "Yesterday"와  '\n'을 덧붙여 기록
		7. **<< 연산자는 문자만 저장하기 때문에**, 정수를 문자열로 바꾸어 저장한다
	- 파일 닫기
		1. fout.close(); // 파일 쓰기를 마치면 close()함수로 **스트림과 파일의 연결을 끊는다.**
	- 연산자 >>를 이용한 텍스트 파일 읽기
		1. ifstream 클래스를 이용하여 파일 입력 스트림 객체를 생성
		2. ifstream fin; // 파일 입력 스트림 객체 생성
		3. fin.open("c:\\student.txt"); // 파일열기
		4. 파일 열기가 성공하면 >> 연산자를 이용하여 파일에서 텍스스 데이터를 읽는다
		5. char name[10], dept[20];
		6. int sid;
		7. fin >> name; // 파일에서 문자열을 읽어 name 배열에 저장
		8. fin >> sid; // 파일에서 정수를 읽어 sid 정수형 변수에 저장(텍스트 파일에 문자로 저장된 숫자를 정수형으로 변환)
		9. fin >> dept; // 파일에서 문자열을 읽어 dept 배열에 저장

* 파일 모드
	- 파일 모드 : 파일을 열 때 앞으로 **어떤 파일 입출력을 수행할 것인지 알리는 정보**
	- 파일 모드 설정
		1. 파일 모드는 파일을 열 때 지정
		2. open() 함수나 ifstream, ofstream, fstream의 생성사를 통해 지정
	- student.txt 파일에서 처음부터 읽고자 하는 경우
		1. 디폴트 파일 모드를 그대로 사용하면 된다
		2. ifstream fin;
		3. fin.opne("student.txt"); // 디폴트 파일 모드(ios::in) 지정. 
		4. fin.opne("student.txt" ios::in);  // 명시적으로 파일모드 지정해도 된다.
	- student.txt 파일의 끝에 데이터를 저장하는 경우
		1. ofstream fout;
		2. fout.open("student.txt", ios::out | ios::app);
		3. fout << "tel:010444777"; // 기존의 student.txt 끝에 "tel:0104447777"을 추가 저장
	- 바이너리 I/O로 data.bin 파일을 기록하는 경우
		1. fstream fbinout;
		2. fbinout.open("data.bin", ios::out | ios::binary);
		3. char buf[128];
		4. .......
		5. fbinout.write(buf, 128); // buf에 있는 128 바이트를 파일에 기록

* 멤버 함수를 이용한 텍스트 I/O
	- get()과 put()을 이용한 텍스트 I/O
		1. 텍스트 I/O 모드인 경우, get()은 파일에서 문자 한 개를 읽고, put()은 문자 한 개를 파일에 기록
	- get()과 EOF
		1. get()은 한 바이트를 읽고 파일 포인터를 **다음 바이트 위치로 전진시킨다.**
		2. get()이 파일의 마지막 문자를 읽고 나면, 파일 포인터는 전진하여 파일의 끝을 가리킨다. 아직은 다음에 데이터가 있는 없는지 모름
		3. 파일 포인터가 파일의 마지막 위치에 있는 상태에서 한 번 더 get()을 실행한다.
		4. 그럼 get()은 더 읽을 수 있는 데이터가 없으므로 파일의 끝임을 알게되고 EOF(-1)을 리턴
		5. 스트림 내부에 **eofbit 플래그를 1(true)**로 설정
---


### 13. 예외처리와 C언어와의 링크 지정
* 실행 오류와 오류처리

* 예외와 예외 처리
	- 예외란? : 실행 중, 프로그램의 오동작이나 결과에 영향을 미치는 예상치 못한 상황발생을 예외(Exception)라고 한다
	- 예외 처리 기본 형식, try-throw-catch
	- 예외가 발생할 소지가 있는 문장들은 try{}블록으로 묶고 예외를 처리할 catch(){} 블록을 바로 연결하여 선언
	- throw가 던진 예외는 연결된 catch(){}블록에서 처리
	- try{} 블록 내에는 여러 개의 throw문이 가능하고 던져진 예외 값의 타입과 일치하는 catch(){}블록이 실행된다
	- catch()의 () 안에 예외값을 받는 예외 파라미터를 선언
	- 예외 파라미터는 한개만 선언 가능

* 예외 처리에 대한 자세한 설명
	- 하나의 try{} 블록에 다수의 catch(){} 블록 연결하여 여러 타입의 예외를 처리할 수 있다
	- 함수를 포함하는 try{}블록 : try{} 블록에서 호출한 함수가 예외를 던진다
	- 예외를 발생시기는 함수의 선언 : 함수에서 발생시키는 모든 예외 타입을 함수 원형 뒤에 throw()의 괄호 안에 나열한다
	- 예시 : double valueAt(double* p, int index) **throw(int, char*)** {}
	- throw문은 항상 try{} 블록 안에서 실행되어야 한다
	- try{}블록 안에 try{}블록 중첩가능
	- catch(){} 블록 내에도 try{} catch(){} 블록을 선언 가능
