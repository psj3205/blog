---
layout: post
title:  "C++ 정리"
date:   2018-10-16 19:51:02 +0900
---

### 1. C++ 시작
* 프로그래밍과 프로그래밍 언어
	- 프로그램 : 컴퓨터가 처리할 일련의 작업을 묘사하는 것
	- 프로그래밍 언어 : 이때 사용하는 컴퓨터 언어
	- 기계어 : 0과 1만의 이진수를 사용하는 가장 원시적인 언어
	- 어셈블리어 : 0과 1만으로 이루어진 기계어의 각 명령어를 ADD, SUB, MOVE 등과 같이 상징적인 니모닉 기호로 일대일 대응 시킨 언어
	- 어셈블러 : 어셈블리어로 작성된 프로그램은 어셈블러에 의해 기계어 프로그램으로 변환되어 컴퓨터에서 실행
	- 고급언어 : 사람이 이해하고 표현하기 쉬우며, 복잡한 알고리즘이나 다양한 프로그램 구조 및 자료를 효율적으로 표현하는 언어
	- 컴파일러 : 고급 프로그래밍 언어로 작성된 프로그램은 컴파일러에 의해 기계어로 변환되어 컴퓨터에서 실행
	- 고급언어->(**컴파일러**)->어셈블리어->(**어셈블러**)->기계어

* 표준 C++ 프로그램의 중요성
	- 미국 국립 표준원인 ANSI에서 C++에 대한 표준을 정함
	- ANSI 표준에 따라 만들어진 C++ 프로그램 소스는 모든 플랫폼, 모든 C++ 컴파일러에 의해 컴파일 가능하고 모두 동일한 실행 결과를 보장한다

* C++ 언어의 특징
	- C++ 언어의 주요한 설계 목표
		1. C언어로 작성된 프로그램과의 호환성
		2. 객체 지향 개념 도입(데이터 캡슐화, 상속, 다형성 등)
		3. 타입 체크를 엄격히 하여 실행 시간 오류의 가능성을 줄이고 디버깅을 돕는다
		4. 실행 시간의 효율성 저하를 최소화(인라인 함수)

	- C언어에 추가한 기능
		1. 인라인 함수 : 자주 호출되는 함수의 경우 함수 호출 대신 함수 코드를 확장 삽입하는 방식, 실행 시간을 줄인다
		2. Function overloading : 매개 변수의 개수나 타입이 서로 다른 동일한 이름의 함수들을 선언할 수 있음
		3. 디폴트 매개 변수 : 매개 변수에 값이 전달되지 않는 경우 디폴트 값이 전달되도록 함수를 선언할 수 있음
		4. 참조와 참조 변수 : 변수에 별명을 붙여 변수 공간을 같이 사용할 수 있는 참조의 개념 도입
		5. 참조에 의한 호출 : 함수 호출 시 참조를 전달할 수 있게 한다
		6. new와 delete연산사 : 동적 메모리 할당, 해제를 위한 new, delete 연산자를 도입
		7. 연산자 재정의(operator overloading) : 기존의 연산자에 새로운 연산을 정의할 수 있다
		8. 제네릭 함수와 클래스 : 함수나 클래스를 데이터 타입에 의존하지 않고 일반화시킬 수 있게 한다

	- C++의 객체 지향 특성
		1. 객체와 캡슐화 : 켑슐화는 C++에서는 class로 구분, class에는 멤버변수와 멤버함수로 구성
		2. 상속성 : 자식 클래스의 객체가 생성될 때 자식 클래스에 선언된 맴버뿐 아니라 부모 클래스에 선언된 멤버들도 함께 가지고 탄생, 재사용성을 높임
		3. 다형성 : 하나의 기능이 경우에 따라 서로 다르게 보이거나 다르게 작동(연산자 중복, 함수 오버로딩(함수 중복), 함수 오버라이딩(함수 재정의) 등)

	- C++에서 객체 지향을 도입한 목적
		1. 소프트웨어 생산성 향상 : 상속, 다형성, 객체 등 소프트웨어의 재사용성을 높이는 기능을 사용하여 소프트웨어 제작 부담 감소
		2. 실세계에 대한 쉬운 모델링 : 관련된 객체들의 상호작용을 묘사하는 것이 실세계의 현상을 모사하는데 더 쉽고 적합하다. 각 요소를 객체로 정의하고, 객체의 속성과 행위를 묘사하고 객체 사이의 상호작용을 표현하는 방법이 더 효과적

	- C++의 약점
		1. C언어와 호환성 때문에 전역변수를 허용, 캡슐화의 원칙이 무너짐

* C++ 프로그램 개발 과정
	- C++ 소스 작성 -> 컴파일 -> 링킹 -> 실행파일 생성
	- 컴파일 : 컴파일러는 소스 프로그램이 문법에 맞게 작성되었는지 검사하고, 기계어 코드로 변환하여 목적 파일을 생성
		1. 컴파일러는 컴파일 전에 전처리기를 실행시켜 #include 문을 실행하여 헤더파일의 텍스트를 소스에 추가
	- 링킹 : 컴파일에 의해 생성된 목적파일을 필요한 라이브러리나 다른 소스와 연결하여 하나의 실행 파일로 만드는 작업
	- 빌드 : 컴파일과 링킹을 모두 시행하여 실행파일을 만드는 과정

---

### 2. C++ 프로그래밍의 기본
	* main()함수
		1. c++ 프로그램의 실행 시작점
		2. c++ 프로그램에는 반드시 하나의 main() 함수가 존재
		3. main() 함수가 종료되면 프로그램이 종료
		int main(){

			return 0;
		}

	* namespace
		- 변수, 함수, 클래스 등의 이름이 충돌하는 것을 막기 위해, 개발자가 자신만의 고유한 이름 공간을 생성할 수 있도록 namespace 키워드를 도입
		- std는 표준 이름 공간으로 모든 c++ 표준 라이브러리는 std 이름 공간에 만들어져 있다

	* cout 객체
		- 스크린 장치와 연결된 c++ 표준 출력 스트림 객체

	* cin 객체
		- 키보드와 연결된 c++ 표준 입력 스트림 객체, 키보드로 입력되는 값들은 모두 cin 객체의 스트림 버퍼에 들어온다

---

### 3. 클래스와 객체
* 객체에 대한 이해
	- 캡슐화  : 객체의 구성요소들을 캡슐로 싸서 보호하고 볼 수 없게 하는 것
	- 객체의 일부 요소는 공개된다 : 객체들이 서로 통신하기 위해 일부 요소는 노출
	- 객체는 맴버 변수와 맴버 함수로 구성

* c++ 클래스 만들기
	- 맴버 변수는 클래스 선언부에서 초기화 될 수 없다
	- 접근 지정자
		1. public, private(디폴트), protected

* 객체 생성과 객체 활용
	- 객체 생성 : 클래스 이름 + 객체 이름
		1. 예 : Circle donut;
	- 객체의 맴버 접근
		1. 객체 이름 뒤에 .을 찍고 뒤에 맴버를 쓴다
		2. 예 : 객체이름.맴버

* 생성자
	-	클래스는 객체가 생성될 때 자동으로 실행되는 생성자라는 특별한 맴버 함수를 통해 객체를 초기화
		1. 생성자의 목적은 객체가 생성될 때 초기 작업을 위해
		2. 오직 한번만 실행
		3. 생성자 함수의 이름은 클래스 이름과 동일하게 작성
		4. 생성자 함수의 리턴 타입은 선언하지 않는다
		5. 생성자는 중복가능

* 소멸자
	- 소멸자는 객체가 소멸되는 시점에서 자동으로 호출되는 클래스의 맴버 함수
	- 객체 소멸 시 소멸자 함수가 반드시 실행된다
		1. 객체가 사라질 때 필요한 마무리 작업을 하기 위해서
		2. 소멸자의 이름은 클래스 이름 앞에 ~를 붙인다
		3. 소멸자는 리턴 타입이 없으며 어떤 값도 리턴해서는 안된다
		4. 소멸자는 오직 한개만 존재, 매개변수를 가지지 않는다
		5. 소멸자가 없을 시에 기본 소멸자가 자동 생성

	- main() 스택에 pop 되는 순으로 소멸자 실행(나중에 호출된 함수가 제일 먼저 소멸자 실행)

* 접근 지정
	- 접근 지정자
		1. private : 클래스 내의 맴버 함수에만 공개
		2. protected : 클래스 내의 맴버와 상속받은 파생 클래스에만 허용
		3. public : 클래스 내외의 모든 함수에게 공개

	- 클래스 외부에서 객체를 생성하기 위해서는 생성자를 public으로 선언해야 한다
