---
layout: post
title:  "C++ 정리"
date:   2018-10-16 19:51:02 +0900
---

### 1. C++ 시작
* 프로그래밍과 프로그래밍 언어
	- 프로그램 : 컴퓨터가 처리할 일련의 작업을 묘사하는 것
	- 프로그래밍 언어 : 이때 사용하는 컴퓨터 언어
	- 기계어 : 0과 1만의 이진수를 사용하는 가장 원시적인 언어
	- 어셈블리어 : 0과 1만으로 이루어진 기계어의 각 명령어를 ADD, SUB, MOVE 등과 같이 상징적인 니모닉 기호로 일대일 대응 시킨 언어
	- 어셈블러 : 어셈블리어로 작성된 프로그램은 어셈블러에 의해 기계어 프로그램으로 변환되어 컴퓨터에서 실행
	- 고급언어 : 사람이 이해하고 표현하기 쉬우며, 복잡한 알고리즘이나 다양한 프로그램 구조 및 자료를 효율적으로 표현하는 언어
	- 컴파일러 : 고급 프로그래밍 언어로 작성된 프로그램은 컴파일러에 의해 기계어로 변환되어 컴퓨터에서 실행
	- 고급언어->(**컴파일러**)->어셈블리어->(**어셈블러**)->기계어

* 표준 C++ 프로그램의 중요성
	- 미국 국립 표준원인 ANSI에서 C++에 대한 표준을 정함
	- ANSI 표준에 따라 만들어진 C++ 프로그램 소스는 모든 플랫폼, 모든 C++ 컴파일러에 의해 컴파일 가능하고 모두 동일한 실행 결과를 보장한다

* C++ 언어의 특징
	- C++ 언어의 주요한 설계 목표
		1. C언어로 작성된 프로그램과의 호환성
		2. 객체 지향 개념 도입(데이터 캡슐화, 상속, 다형성 등)
		3. 타입 체크를 엄격히 하여 실행 시간 오류의 가능성을 줄이고 디버깅을 돕는다
		4. 실행 시간의 효율성 저하를 최소화(인라인 함수)

	- C언어에 추가한 기능
		1. 인라인 함수 : 자주 호출되는 함수의 경우 함수 호출 대신 함수 코드를 확장 삽입하는 방식, 실행 시간을 줄인다
		2. Function overloading : 매개 변수의 개수나 타입이 서로 다른 동일한 이름의 함수들을 선언할 수 있음
		3. 디폴트 매개 변수 : 매개 변수에 값이 전달되지 않는 경우 디폴트 값이 전달되도록 함수를 선언할 수 있음
		4. 참조와 참조 변수 : 변수에 별명을 붙여 변수 공간을 같이 사용할 수 있는 참조의 개념 도입
		5. 참조에 의한 호출 : 함수 호출 시 참조를 전달할 수 있게 한다
		6. new와 delete연산사 : 동적 메모리 할당, 해제를 위한 new, delete 연산자를 도입
		7. 연산자 재정의(operator overloading) : 기존의 연산자에 새로운 연산을 정의할 수 있다
		8. 제네릭 함수와 클래스 : 함수나 클래스를 데이터 타입에 의존하지 않고 일반화시킬 수 있게 한다

	- C++의 객체 지향 특성
		1. 객체와 캡슐화 : 켑슐화는 C++에서는 class로 구분, class에는 멤버변수와 멤버함수로 구성
		2. 상속성 : 자식 클래스의 객체가 생성될 때 자식 클래스에 선언된 맴버뿐 아니라 부모 클래스에 선언된 멤버들도 함께 가지고 탄생, 재사용성을 높임
		3. 다형성 : 하나의 기능이 경우에 따라 서로 다르게 보이거나 다르게 작동(연산자 중복, 함수 오버로딩(함수 중복), 함수 오버라이딩(함수 재정의) 등)

	- C++에서 객체 지향을 도입한 목적
		1. 소프트웨어 생산성 향상 : 상속, 다형성, 객체 등 소프트웨어의 재사용성을 높이는 기능을 사용하여 소프트웨어 제작 부담 감소
		2. 실세계에 대한 쉬운 모델링 : 관련된 객체들의 상호작용을 묘사하는 것이 실세계의 현상을 모사하는데 더 쉽고 적합하다. 각 요소를 객체로 정의하고, 객체의 속성과 행위를 묘사하고 객체 사이의 상호작용을 표현하는 방법이 더 효과적

	- C++의 약점
		1. C언어와 호환성 때문에 전역변수를 허용, 캡슐화의 원칙이 무너짐

* C++ 프로그램 개발 과정
	- C++ 소스 작성 -> 컴파일 -> 링킹 -> 실행파일 생성
	- 컴파일 : 컴파일러는 소스 프로그램이 문법에 맞게 작성되었는지 검사하고, 기계어 코드로 변환하여 목적 파일을 생성
		1. 컴파일러는 컴파일 전에 전처리기를 실행시켜 #include 문을 실행하여 헤더파일의 텍스트를 소스에 추가
	- 링킹 : 컴파일에 의해 생성된 목적파일을 필요한 라이브러리나 다른 소스와 연결하여 하나의 실행 파일로 만드는 작업
	- 빌드 : 컴파일과 링킹을 모두 시행하여 실행파일을 만드는 과정

---

### 2. C++ 프로그래밍의 기본
* main()함수
	1. c++ 프로그램의 실행 시작점
	2. c++ 프로그램에는 반드시 하나의 main() 함수가 존재
	3. main() 함수가 종료되면 프로그램이 종료
	int main(){

		return 0;
	}

* namespace
	- 변수, 함수, 클래스 등의 이름이 충돌하는 것을 막기 위해, 개발자가 자신만의 고유한 이름 공간을 생성할 수 있도록 namespace 키워드를 도입
	- std는 표준 이름 공간으로 모든 c++ 표준 라이브러리는 std 이름 공간에 만들어져 있다

* cout 객체
	- 스크린 장치와 연결된 c++ 표준 출력 스트림 객체

* cin 객체
	- 키보드와 연결된 c++ 표준 입력 스트림 객체, 키보드로 입력되는 값들은 모두 cin 객체의 스트림 버퍼에 들어온다

---

### 3. 클래스와 객체
* 객체에 대한 이해
	- 캡슐화  : 객체의 구성요소들을 캡슐로 싸서 보호하고 볼 수 없게 하는 것
	- 객체의 일부 요소는 공개된다 : 객체들이 서로 통신하기 위해 일부 요소는 노출
	- 객체는 맴버 변수와 맴버 함수로 구성

* c++ 클래스 만들기
	- 맴버 변수는 클래스 선언부에서 초기화 될 수 없다
	- 접근 지정자
		1. public, private(디폴트), protected

* 객체 생성과 객체 활용
	- 객체 생성 : 클래스 이름 + 객체 이름
		1. 예 : Circle donut;
	- 객체의 맴버 접근
		1. 객체 이름 뒤에 .을 찍고 뒤에 맴버를 쓴다
		2. 예 : 객체이름.맴버

* 생성자
	-	클래스는 객체가 생성될 때 자동으로 실행되는 생성자라는 특별한 맴버 함수를 통해 객체를 초기화
		1. 생성자의 목적은 객체가 생성될 때 초기 작업을 위해
		2. 오직 한번만 실행
		3. 생성자 함수의 이름은 클래스 이름과 동일하게 작성
		4. 생성자 함수의 리턴 타입은 선언하지 않는다
		5. 생성자는 중복가능

* 소멸자
	- 소멸자는 객체가 소멸되는 시점에서 자동으로 호출되는 클래스의 맴버 함수
	- 객체 소멸 시 소멸자 함수가 반드시 실행된다
		1. 객체가 사라질 때 필요한 마무리 작업을 하기 위해서
		2. 소멸자의 이름은 클래스 이름 앞에 ~를 붙인다
		3. 소멸자는 리턴 타입이 없으며 어떤 값도 리턴해서는 안된다
		4. 소멸자는 오직 한개만 존재, 매개변수를 가지지 않는다
		5. 소멸자가 없을 시에 기본 소멸자가 자동 생성

	- main() 스택에 pop 되는 순으로 소멸자 실행(나중에 호출된 함수가 제일 먼저 소멸자 실행)

* 접근 지정
	- 접근 지정자
		1. private : 클래스 내의 맴버 함수에만 공개
		2. protected : 클래스 내의 맴버와 상속받은 파생 클래스에만 허용
		3. public : 클래스 내외의 모든 함수에게 공개

	- 클래스 외부에서 객체를 생성하기 위해서는 생성자를 public으로 선언해야 한다

* 인라인 함수
	- 짧은 코드로 구성된 함수에 대해, 함수 호출 오버헤드로 인한 프로그램의 실행 속도 저하를 막기 위해 도입된 방법
	- 컴파일러는 인라인 함수를 호출하는 곳에 인라인 함수의 코드를 그대로 삽입하여 함수 호출이 일어나지 않게 한다
	- 생성자를 포함하여 클래스의 모든 멤버 함수가 인라인을 선언 가능

---

### 4. 객체 포인터와 객체 배열, 객체의 동적 생성
* 객체 포인터
	- 객체 이름으로 맴버를 접근할 때는 점(.) 연산자 사용
	- 객체 포인터로 맴버를 접근할 때는 -> 연산자 사용

* 객체 배열
	- 기본 타입의 배열 선언과 동일
	- 객체 배열 선언 시 오직 매개 변수 없는 기본 생성자를 호출
	- 객체 배열이 소멸 시, 높은 인덱스에서부터 원소 객체가 소멸되고, 각 객체마다 소멸자가 실행
	- 객체 배열을 생성할 때 {} 안에 매개 변수가 있는 생성자를 사용하여 생성할 수 있다
	-	예: Circle circleArray[3] = {circle(10), circle(20), circle()};

* 동적메모리 할당 및 반환
	- new 연산자 : 힙 시스템 공간에서 데이터타입의 크기만큼 메모리를 할당받고 주소를 리턴
	- delete 연산자 : 할당 받은 메모리를 힙으로 반환(동적할당 받은 메모리만)
	- int * pInt = new int; : int 타입의 정수공간 할당
	- circle * pCircle = new Circle(); : circle 클래스 타입의 객체 할당

* 배열의 동적 할당 및 반환
	- 데이터 타입 * 포인터변수명 = new 데이터 타입 [배열길이];
	- delete [] 포인터변수명
	- new로 배열을 동적 할당 받을 때 초기값 지정 불가

* 객체의 동적 생성 및 반환
	- 클래스 이름 * 포인터명 = new 클래스이름(생성자매개변수);
	- delete가 실행되면 객체 반환전에 객체의 소멸자 실행

* this 포인터
	- 객체 자신에 대한 포인터로 클래스의 맴버 함수 내에서만 사용
	- this 포인터가 필요한 경우
		1. 맴버 변수의 이름으로 매개변수를 만들 경우
		2. 클래스의 맴버 함수에서 객체자신의 주소를 리턴하고 싶은 경우

---

### 5. 함수와 참조, 복사 생성자
* 참조
	- 값에 의한 호출 : 실인자 값이 매개 변수에 복사되어 전달되는 방식
	- 주소에 의한 호출 : 포인터로 실인자가 연결되어 주소를 직접 포인터 타입의 매개 변수에 전달받는 방식
	- 참조에 의한 호출 : 이미 선언된 변수에 대한 별명, 참조자(&)를 이용하여 선언
		1. 예 : Circle circle;	Circle &refc = circle;
	- 참조 변수는 포인터가 아니므로 -> 연산자 사용못함
	- 참조 변수에 대한 참조 선언 가능

* 복사 생성자
	- 얕은 복사 생성자의 문제점
		1. 포인터 타입의 맴버 변수가 없는 클래스의 경우 문제 없다
		2. 그러나 클래스가 포인터 맴버 변수를 가지고 있는 경우, 원복 객체의 포인터 맴버 변수가 사본 객체의 포인터 맴버 변수에 복사되면 둘은 같은 메모리를 가리키게 되어 문제가 발생

---

### 6. 함수 중복과 static 멤버
* 함수 중복
	- 같은 이름의 함수를 여려개 만들 수 있다
	- 중복 함수 조건
		1. 함수의 이름이 동일
		2. 매개 변수 타입이나 매개 변수 개수가 다르다
		3. 리턴타입은 함수 중복 조건에 없다(리턴 타입만 다른 함수는 함수 중복 아니다)
	- 소멸자는 원래 클래스 당 1개이므로 소멸자 함수 중복 불가능

* 디폴트 매개 변수
	- 예 : void star(int a=5);
	- 매개 변수 없이 함수 호출시 자동을 디폴트 매개변수가 입력

* 함수 중복의 모호성
	- 형 변환으로 인한 모호성
		1. float square(float a);
		2. double square(double a);
		3. square(3) 은 어떤것을 실행할지 모른다
	- 참조 매개 변수로 인한 모호성
		1. int add(int a, int b);
		2. ind add(int a, int &b);
	- 디폴트 매개 변수로 인한 모호성
		1. void msg(int id);
		2. void msg(int id, string s="")
		3. msg(6)은 어느 것을 호출할지 모른다

---


### 8. 상속
* 상속의 개념
	- 객체 지향 언어에서 상속은 부모 유전자를 자식이 물려받는 유전적 상속과 유사
	- 이미 만들어진 클래스의 맴버들을 물려받게 함으로써 코드의 중복작성을 없애고 코드 작성에 드는 시간과 비용을 줄인다

* 상속의 목적과 개념
	- 간결한 클래스 작성 : 클래스들 사이의 중복을 제거
	- 클래스간의 계층적 분류 및 관리의 용이함
	- 클래스 재사용과 확장을 통한 소프트웨어 생산성 향상

* 클래스 상속과 객체
	- 상속은 class 선언 뒤에, 콜론과 기본 클래스 이름을 선언, 이때 기본 클래스 이름 앞에 반드시 상속 접근을 지정한다
	- 상속 횟수는 제한 없다
	- 파생 클래스 객체는 기본 클래스의 맴버와 파생 클래스의 맴버를 모두 가진다
	- 파생 클래스는 상속을 통해 기본 클래스 멤버를 자신의 맴버로 확장
		1. 파생클래스의 멤버들은 기본 클래스의 private 맴버 외에 모든 멤버를 접근 가능
		2. 기본클래스의 private 맴버는 기본클래스 내의 맴버에서만 접근 가능

* protected 접근 지정
	- 기본 클래스에 protected로 지정된 맴버는 파생 클래스에게 접근을 허용하고 다른 클래스나 외부함수에서 접근 불가능

* 상속과 생성자, 소멸자
	- 파생 클래스 객체가 생성될 때 파생클래스생성자와 기본 클래스 생성자 모두 실행
	- 기본 클래스 생성자 먼저 실행
	- 소멸자는 생성자 순서 반대로
	- 파생클래스의 생성자에 대해 함께 실행될 기본 클래스의 생성자를 명시적으로 지정하지 않으면, 컴파일러는 묵시적으로 기본 클래스의 기본 생성자를 실행(파생클래스 생성자에 매개변수가 있다고 해도 기본 클래스의 기본생성자 실행)

* 다중 상속
	- 하나의 파생 클래스가 여러 클래스를 동시에 상속 받는 것

* 가상 상속
	- 다중 상속의 문제점
		1. 다중 상속된 파생클래스가 객체를 생성할때 같은 맴버변수가 중복되어 생성된다
		2. 중복된 변수를 구분할 수 없으므로 컴파일러는 오류를 낸다

	- 파생클래스를 선언할때 기본 클래스 앞에 virtual 키워드를 사용하여 가상 상속을 선언하여 문제를 해결
	- virtual은 기본 클래스의 맴버 공간을 오직 한번만 할당


---


### 9. 가상 함수와 추상 클래스
* 상속 관계에서의 함수 중복
	- 오버로딩을 통해 기본 클래스의 함수와 동일한 함수를 파생클래스에 선언할 수 있다

* 가상 함수와 오버라이딩
	- 가상함수와 오버라이딩은 상속에 기반을 둔 기술로 객체 지향의 꽃이다
	- 오버라이딩은 파생 클래스에서 기본 클래스에 작성된 함수를 중복 작성하여
	- 기본 클래스에 작성된 가상 함수를 무력화시키고, 객체의 주인 노릇을 하는 것이다
	- 기본 클래스의 포인터를 쓰던 파생 클래스의 포인터를 쓰던 가상함수를 호출하면 파생클래스에 오버라이딩된 함수가 실행
	- 가상 함수란 virtual 키워드로 선언된 맴버 함수
	- 파생 클래스에서 기본 클래스의 가상함수와 완전히 동일한 원형의 함수를 재정의 하는 것을 오버라이딩이라고 한다
	- 함수 오버로딩은 객체 안에 같은 함수가 두개 존재하고 두개 모두 호출 가능, 함수 오버라이딩은 두개의 함수가 존재하지만 하나는 죽고 항상 나머지 하나가 호출됨
	- 업캐스팅된 기본클래스 타입의 포인터로 기본클래스의 가상 맴버 함수를 호출해도 자동으로 동적 바인딩되어 오버라이딩된 파생클래스의 맴버함수가 호출된다

* 오버라이딩의 목적
	- 기본 클래스에 가상함수를 만드는 목적은 파생클래스들이 자신의 목적에 맞게 가상함수를 재정의 하도록 하는 것
	- 가상함수는 하나의 인터페이스에 대해 서로 다른 모양의 구현이라는 객체 지향 언어의 다형성을 실현하는 도구

* **동적 바인딩**
	- 가상 함수를 호출하는 코드를 컴파일할 때, 컴파일러는 바인딩을 실행 시간에 결정하도록 미룬다
	- 나중에 가상함수가 호출되면, 실행 중에 객체 내에 오버라이딩된 가상 함수를 동적으로 찾아 호출
	- 이 과정을 동적 바인딩이라고 한다
	- 기본 클래스의 객체에 대해서는 가상함수가 호출된다고 해도 동적바인딩이 일어나지 않는다
	- 파생 클래스의 객체에 대해, 기본 클래스의 포인터로 가상함수가 호출될 때 일어난다
		1. 기본 클래스 내의 맴버함수가 가상 함수 호출
		2. 파생 클래스 내의 맴버함수가 가상 함수 호출
		3. 외부 함수에서 기본클래스의 포인터로 가상함수 호출
		4. 다른 클래스에서 가상함수 호출

* C++ 오버라이딩의 특징
	- 가상함수의 이름과 매개변수 타입, 개수뿐아니라 리턴 타입도 일치해야 오버라이딩이 성공한다
	- 파생 클래스에서 virtual 키워드를 생략해도 자동으로 가상 함수가 된다

* 오버라이딩과 범위 지정 연산자(::)
	- 범위 지정연산자(::)를 이용하여 기본 클래스의 가상함수를 호출할 수 있다
	- 가상함수 정적바인딩이다

* 가상 소멸자
	- 기본 클래스의 소멸자를 만들 때 가상 함수로 작성할 것을 권한다
	- 파생클래스의 객체가 기본 클래스에 대한 포인터로 delete되는 상황에서 정상적인 소멸이 되도록하기 위해서
	- Base * p = new Derived();
	  delete p;
	- p가 Base 타입이므로 컴파일러는 ~Base() 소멸자를 호출하도록 컴파일한다 그러므로 ~Base()만 실행되고 ~Derived()는 실행되지 않는다

* 가상 함수와 오버라이딩의 활용 사례
	- 가상 함수는 파생 클래스에서 재정의할 함수를 알려주는 인터페이스의 역할을 한다
		1. 가상함수를 가진 기본 클래스의 목적
		2. 가상 함수 오버라이딩
		3. 동적 바인딩 실행
		4. 기본 클래스의 포인터 활용

* 추상 클래스
	- 순수 가상함수
		1. 기본 클래스에 작성된 가상함수는 실행할 목적보다는 파생 클래스에서 재정의하여 구현할 함수를 알려주는 인터페이스역할이다
		2. 파생클래스에서 가상함수를 재정의 하면, 동적 바인딩에 의해 기본 클래스의 가상함수는 거의 실행되지 않는다
		3. 순수 가상함수는 함수의 코드가 없고 선언만 있는 가상함수
		4. 순수 가상 함수는 맴버 함수의 원형 뒤에 =0;으로 선언

	- 추상 클래스
		1. 최소 하나의 순수 가상 함수를 가진 클래스를 추상 클래스라고 한다
		2. 추상 클래스는 실행 코드가 없는 순수 가상함수를 가지고 있기 때문에 불완전한 클래스이다.
		3. 그러므로 응용프로그램에서 추상 클래스의 인스턴스를 생성할 수 없다.
		4. 그러나 추상 클래스에 대한 포인터 선언은 문제 되지 않는다.

	- 추상 클래스의 목적
		1. 인스턴스를 생성할 목적이 아니라, 상속을 위한 기본 클래스로 활용하는 것이 목적

	- 추상 클래스를 상속받는 파생 클래스는 자동으로 추상 클래스가 된다
		1. 그래서 파생클래스에 순수 가상함수를 오버라이딩하지 않으면 인스턴스를 생성할 수 없다

	- 추상 클래스의 구현
		1. 파생 클래스가 온전한 클래스가 되려면 상속받은 추상 클래스의 모든 순수 가상함수를 오버라이딩하여 구현하여야 한다
		2. 그럼 파생 클래스는 인스턴스를 생성할 수 있다


---


### 10. 템플릿과 STL
* 일반화와 템플릿
	- 함수중복으로 다른부분은 모두 같고 매개변수 타입만 다른 함수들을 구현한다면 관리가 번거롭고 프로그램 길이도 증가
	- 템플릿 : 매개 변수 타입만 다른 중복된 함수들을 일반화 시킨 틀
	- template 키워드를 이용하면 중복 함수들을 일반화시킨 특별한 함수를 만들 수 있다
	- 이를 템플릿 함수 혹은 제네릭 함수라고 한다
	- 예시
		template <class T>
		void myswap (T &a, T &b){

		}
	- 템플릿으로부터 구체화
		1. int a=4, b=5; myswap(a,b);
		2. 컴파일러는 myswap(a,b); 호출문을 컴파일할 때 myswap()함수를 찾는다
		3. 템플릿으로 선언된 myswap() 함수를 발견
		4. 구체화한다. myswap(a,b);의 함수 호출문에서 실인자 a, b가 모두 int타입이므로, 템플릿의 제네릭 타입T에 int를 대입시켜 myswap(int &a, int &b)의 소스 코드를 만든다
		5. 구체화된 함수의 코드를 컴파일하고, 이함수를 호출한다
	- 클래스 타입도 템플릿의 타입매개변수로 가능
	- 구체화 오류
		1. myswap함수의 매개 변수는 모두 T타입으로 선언되어 있기 때문에, 템플릿 함수를 호출할 때 매개 변수들의 타입은 모두 같아야 한다
	- 템플릿의 장단점
		1. 함수의 작성의 용이
		2. 함수 코드의 재사용성을 높인다
		3. 생산성과 유연성을 높인다
		4. 템플릿 관련 컴파일 오류 메시지가 빈약하여 디버깅에 어려움이 있다

* 다양한 제네릭 함수 만들기
	- 두 개 이상의 제네릭 타입을 가진 경우도 가능
	- template <class T1, class T2>
		void mcopy(T1 src [], T2 dest [], int n)
	- src [] 타입은 T1, dest [] 타입은 T2로 서로 다르다. 그러므로 mcopy() 호출 시, 두 매개 변수에 동일한 타입의 배열을 넘길 수도 있고, 다른 타입의 배열을 넘길 수도 있다
	- 템플릿 함수와 이름이 동일한 함수가 중복되어 있을 때, 컴파일러는 중복된 함수를 템플릿 함수보다 우선하여 바인딩한다
	- 템플릿 함수선언에 디폴트 매개변수 사용 가능
	- 예시 : template <class T1, class T2>
					void mcopy(T1 src [], T2 dest [], int n = 5){}


---


### 11. C++ 입출력 시스템
* C++ 입출력 기초
	- 스트림 : 연속적인 데이터의 흐름 혹은 데이터를 전송하는 소프트웨어 모듈
	- 스트림은 프로그램과 장치를 연결하며 바이트 단위로 입출력한다
	- c++ 입출력 스트림의 중요한 특징은 스트림이 버퍼를 가진다
		1. 키 입력 스트림 버퍼 : 엔터키 입력이 들어오기 전까지 그동안 입력된 문제들이 입력 스트립 버퍼에 저장된다
		2. 스크린 출력 스트림 버퍼 : C++ 프로그램이 문자열을 출력하면 일단 출력 스트림 버퍼에 저장된 후, '\n'이 도착하거나 버퍼가 꽉차면 출력한다


---


### 13. 예외처리와 C언어와의 링크 지정
* 실행 오류와 오류처리

* 예외와 예외 처리
	- 예외란? : 실행 중, 프로그램의 오동작이나 결과에 영향을 미치는 예상치 못한 상황발생을 예외(Exception)라고 한다
	- 예외 처리 기본 형식, try-throw-catch
	- 예외가 발생할 소지가 있는 문장들은 try{}블록으로 묶고 예외를 처리할 catch(){} 블록을 바로 연결하여 선언
	- throw가 던진 예외는 연결된 catch(){}블록에서 처리
	- try{} 블록 내에는 여러 개의 throw문이 가능하고 던져진 예외 값의 타입과 일치하는 catch(){}블록이 실행된다
	- catch()의 () 안에 예외값을 받는 예외 파라미터를 선언
	- 예외 파라미터는 한개만 선언 가능

* 예외 처리에 대한 자세한 설명
	- 하나의 try{} 블록에 다수의 catch(){} 블록 연결하여 여러 타입의 예외를 처리할 수 있다
	- 함수를 포함하는 try{}블록 : try{} 블록에서 호출한 함수가 예외를 던진다
	- 예외를 발생시기는 함수의 선언 : 함수에서 발생시키는 모든 예외 타입을 함수 원형 뒤에 throw()의 괄호 안에 나열한다
	- 예시 : double valueAt(double* p, int index) **throw(int, char*)** {}
	- throw문은 항상 try{} 블록 안에서 실행되어야 한다
	- try{}블록 안에 try{}블록 중첩가능
	- catch(){} 블록 내에도 try{} catch(){} 블록을 선언 가능
