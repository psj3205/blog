---
layout: post
title:  "Unity Doc"
date:   2019-01-29 14:58:02 +0900
---

### 그래픽스
* 그래픽스 개요
	- 조명
		1. 조명 개요
			1. 실시간 조명
				- Unity의 기본 광원은 **방향광원, 스폿 및 점 광원 그리고 실시간 광원**
				- 실시간 광원은 씬에 비치는 직접광에 기여하고 **모든 프레임**마다 업데이트
				- Unity의 실시간 광원에서 나오는 광선은 단독으로 사용할 경우 반사된 빛이 2차 광원으로 사용되지 않음
				- 전역 조명 등의 기법을 사용하여 더 사실적인 씬을 만들기 위해서는 Unity의 **미리 계산된** 조명 솔루션을 활성화해야 함
			
			2. 베이크된 라이트맵
				- Unity는 **전역 조명(GI)**라는 기법을 사용하여 복잡한 정적 조명 효과를 계산하고 **라이트맵이라는 레퍼런스 텍스처** 맵에 저장할 수 있음
				- 이 프로세스를 베이킹이라 함
				- 라이트맵을 베이크할 때는 광원이 씬의 정적 오브젝트에 미치는 영향이 계산되고 계산 결과가 텍스쳐에 기록(그림자도 텍스쳐에 기록)
				- 이 텍스쳐는 씬 지오메트리 위에 오버레이 되어 조명 효과를 만듬
				- 이런 라이트맵에는 표면에 닿는 **직접광**과 씬의 다른 오브젝트나 표면에 반사되는 **간접광**이 모두 포함될 수 있음
				- 베이크된 조명을 사용하는 경우 게임 플레이 중에 변경 불가능하므로 **정적 라이트맵**이라고 함

			3. 미리 계산된 실시간 전역 조명
				- 정적 라이트맵은 씬 내 조명 상태의 변화에 반응할 수 없지만, **미리 계산된 실시간 GI**는 복잡한 씬 조명을 대화식으로 업데이트하는 기법으로 사용 가능
				- 이 방식은 조명 변화에 **실시간으로 반응**하는 반사광을 사용한 풍부한 전역 조명을 비춘 환경을 만들 수 있음
				- 광원의 위치와 컬러가 시간에 따라 변하는 타임오브데이 시스템 구현 가능. 기존 베이크된 조명으로는 불가능
				- 이런 효과를 플레이 가능한 프레임 속도로 제공하기 위해서는 긴 시간이 걸리는 양의 계산 일부를 실시간 프로세스에서 미리 계산하는 프로세스로 전환해야 함
				- 이를 **오프라인 프로세스**라고 함

			4. 장점과 비용
				- 베이크된 GI 조명과 미리 계산된 실시간 GI를 동시에 사용할 수 있음
				- 하지만 두 시스템을 모두 동시에 렌더링하는 데 사용되는 리소스의 양은 각 시스템을 렌더링하는 데 사용되는 리소스의 양을 합한 것과 정확히 동일함
				- 두 라이트맵 집합을 비디오 메모리에 저장해야 할 뿐만 아니라 둘을 모두 셰이더에서 디코딩해야 하므로 처리 성능이 2배 필요
				

---

### 2. 캐릭터 제작
* 스크립트
	- Awake
		1. 스크립트가 실행될 때 한 번만 호출되는 함수
		2. 주로 게임의 상태 값 또는 변수의 초기화에 사용
		3. Start 함수가 호출되기 전에 맨 먼저 호출
		4. 스크립트가 비활성화 되어 있어도 실행
		5. 코루틴 사용불가
	- Start
		1. Update 함수가 호출되기 전에 한 번만 호출
		2. 스크립트가 활성화 되어 있어야 실행
		3. 다른 스크립트의 모든 Awake가 모두 다 실행된 이후에 실행
	- Update
		1. 프레임마다 호출되는 함수로 주로 게임의 핵심 로직을 작성
		2. 스크립트가 활성화 되어 있어야 실행
	- LateUpdate
		1. 모든 Update 함수가 호출되고 나서 한 번씩만 호출
		2. 순차적으로 실행해야 하는 로직에 사용
		3. 카메라 이동 로직에 주로 사용하는 함수
		4. 스크립트가 활성화 되어 있어야 실행
	- FixedUpdate
		1. 주로 물리 엔진을 사용하는 경우에 일정 시간 간격으로 힘을 가할 때 사용하는 함수
		2. 발생하는 주기가 일정
	- OnEnable
		1. 게임오브젝트 또는 스크립트가 활성화 되었을 때 호출
		2. 이벤트 연결 시 사용
		3. 코루틴 사용 불가
	- OnDisable
		1. 게임오브젝트 또는 스크립트가 비활성화 되었을 때 호출
		2. 이벤트 연결을 종료할 때 사용
		3. 코루틴 사용 불가
	
---

### 3. 발사체 제작
* Rigidbody 컴포넌트
	- Rigidbody 컴포넌트를 게임오브젝트에 추가하면 해당 게임오브젝트는 중력의 영향을 즉시 받기 시작
	- Collider 컴포넌트도 하나 이상 추가할 경우 게임 오브젝트가 당하는 충돌에 의해 움직임
	- Rigidbody 컴포넌트는 연결된 게임 오브젝트의 이동을 제어하므로 스크립트에서 포지션과 회전 같은 트랜스폼 프로퍼티를 변경하여 오브젝트를 이동하면 안됨
	- 대신 Forces를 가하여 게임 오브젝트를 밀고 물리 엔진이 결과를 계산하도록 해야 함
	- 게임 오브젝트에 리지드바디를 연결하되, 물리 엔진으로 모션이 제어되는 것을 원치 않는 경우 is Kinematic 프로퍼티를 선택
	- 하지만 성능 오버헤드가 발생하므로 신중해야 함
* Collider 컴포넌트
	- 충돌을 감지하기 위한 컴포넌트

* 충돌감지 조건
	- 충돌을 일으키는 양쪽 오브젝트 모두 Collider 컴포넌트가 있어야 함
	- 두 게임오브젝트 중 움직이는 쪽에는 반드시 Rigidbody 컴포넌트가 있어야 함

* 정적 콜라이더
	- 콜라이더는 있지만 리지드바디는 없는 게임 오브젝트
	- 리지드바디 오브젝트가 다가오면 정적 콜라이더와 충돌하지만 정적 콜라이더는 움직이지 않음

* 리지드바디 콜라이더
	- 일반 비키네마틱 리지드바디와 콜라이더가 있는 게임 오브젝트
	- 리지드바디 콜라이더는 물리 엔진에 의해 완전히 시뮬레이션되며 스크립트로부터 적용되는 충돌과 힘에 반응

* 키네마틱 리지드바디 콜라이더
	- 키네마틱 리지드바디오브젝트는 Transform 컴포넌트를 수정하여 스크립트를 통해 움직일 수 있음
	- 하지만 비키네마틱 리지드바디의 경우와 같은 충돌이나 힘에는 반응하지 않음

---

### 추가항목. 드로우콜(배치)
* 드로우 콜(배치)
	- 오브젝트, 파티클 등 CPU에 의해 연산된 정보를 GPU에 넘겨주어 최종적으로 GPU가 화면에 출력한다
	- 이 때 CPU가 GPU를 호출하는 것을 드로우 콜이라고 한다

* Set Pass Call
	- 머티리얼과 쉐이더에 관련된 것에 대한 배치
	- 아틀라스를 활용하여 여러 오브젝트들을 한개의 머티리얼로 묶어서 Set Pass Call을 감소시켜야 한다

* 아틀라스
	- 오브젝트의 수가 많더라도 같은 텍스처를 사용한다면 드로우콜은 한번만 발생
	- 따라서 하나의 텍스처에 많은 이미지들을 모아서 드로우콜을 감소시킨다
	- 이것을 아틀라스라고 한다
	
* 배칭 
	- 복수의 드로우콜을 하나의 드로우콜로 묶어서 처리하는 작업
	- CPU가 GPU에 랜더링 요청을 할 때 데이터 처리 작업을 한꺼번에 해줘서 GPU의 부담을 줄인다

* 동적 배칭
	- 동일한 머티리얼을 공유하고, 버텍스 개수가 총 300이하의 메쉬만 적용 가능(이외의 조건 존재)
	- 유니티에 의해 자동 적용

* 정적 배칭
	- 동일한 머터리얼을 공유하고, 움직이지 않는 오브젝트에 적용할 수 있는 배칭
	- 적용 효과가 크다
	- 메쉬를 강제적으로 합쳐서 메모리에 부담을 준다

* 리얼타임 쉐도우
	- 리얼타임 쉐도우를 해제