---
layout: post
title:  "Unity Doc"
date:   2019-01-29 14:58:02 +0900
---

### 그래픽스
* 그래픽스 개요
	- 조명
		1. 조명 개요
			1. 실시간 조명
				- Unity의 기본 광원은 **방향광원, 스폿 및 점 광원 그리고 실시간 광원**
				- 실시간 광원은 씬에 비치는 직접광에 기여하고 **모든 프레임**마다 업데이트
				- Unity의 실시간 광원에서 나오는 광선은 단독으로 사용할 경우 반사된 빛이 2차 광원으로 사용되지 않음
				- 전역 조명 등의 기법을 사용하여 더 사실적인 씬을 만들기 위해서는 Unity의 **미리 계산된** 조명 솔루션을 활성화해야 함
			
			2. 베이크된 라이트맵
				- Unity는 **전역 조명(GI)**라는 기법을 사용하여 복잡한 정적 조명 효과를 계산하고 **라이트맵이라는 레퍼런스 텍스처** 맵에 저장할 수 있음
				- 이 프로세스를 베이킹이라 함
				- 라이트맵을 베이크할 때는 광원이 씬의 정적 오브젝트에 미치는 영향이 계산되고 계산 결과가 텍스쳐에 기록(그림자도 텍스쳐에 기록)
				- 이 텍스쳐는 씬 지오메트리 위에 오버레이 되어 조명 효과를 만듬
				- 이런 라이트맵에는 표면에 닿는 **직접광**과 씬의 다른 오브젝트나 표면에 반사되는 **간접광**이 모두 포함될 수 있음
				- 베이크된 조명을 사용하는 경우 게임 플레이 중에 변경 불가능하므로 **정적 라이트맵**이라고 함

			3. 미리 계산된 실시간 전역 조명
				- 정적 라이트맵은 씬 내 조명 상태의 변화에 반응할 수 없지만, **미리 계산된 실시간 GI**는 복잡한 씬 조명을 대화식으로 업데이트하는 기법으로 사용 가능
				- 이 방식은 조명 변화에 **실시간으로 반응**하는 반사광을 사용한 풍부한 전역 조명을 비춘 환경을 만들 수 있음
				- 광원의 위치와 컬러가 시간에 따라 변하는 타임오브데이 시스템 구현 가능. 기존 베이크된 조명으로는 불가능
				- 이런 효과를 플레이 가능한 프레임 속도로 제공하기 위해서는 긴 시간이 걸리는 양의 계산 일부를 실시간 프로세스에서 미리 계산하는 프로세스로 전환해야 함
				- 이를 **오프라인 프로세스**라고 함

			4. 장점과 비용
				- 베이크된 GI 조명과 미리 계산된 실시간 GI를 동시에 사용할 수 있음
				- 하지만 두 시스템을 모두 동시에 렌더링하는 데 사용되는 리소스의 양은 각 시스템을 렌더링하는 데 사용되는 리소스의 양을 합한 것과 정확히 동일함
				- 두 라이트맵 집합을 비디오 메모리에 저장해야 할 뿐만 아니라 둘을 모두 셰이더에서 디코딩해야 하므로 처리 성능이 2배 필요

		2. 라이팅 창
			1. 개요
				- **Lighting창(Window > Rendering > Lighting Settings)**은 Unity의 전역 조명 기능을 제어하는 주요 지점
				- 라이팅 창의 컨트롤은 세 개의 탭으로 구분
				- Scene 탭의 설정은 개별 게임 오브젝트가 아니라 전체 씬에 적용
				- Global maps 탭에는 GI 조명 프로세스에서 생성된 모든 라이트맵 에셋 파일이 표시
				- Object maps 탭에는 현재 선택된 게임 오브젝트의 GI 라이트맵 텍스처 미리보기가 표시
				- 라이팅 창의 하단에는 Auto Generate 체크박스가 있음. 체크박스를 선택하면 씬을 편집할 때 라이트맵 데이터가 자동으로 업데이트

		3. 광원
			1. 광원 타입
				1. 점 광원(Point Lights)
					- 공간의 한 점에 있고, 광원을 **모든 방향으로 균등하게** 내보냄
					- 광도는 광원에서 거리가 멀어질수록 약해지고, 지정된 거리에서 0이 됨
					- 씬에 있는 램프와 기타 로컬 광원을 시뮬레이션하는 데 유용

				2. 스폿 광원(Spot Lights)
					- 점 광원과 마찬가지로 광원이 떨어지는 지정된 위치와 범위가 존재
					- 하지만 스폿 광원은 **특정 각도로 제약**되므로 조명이 비추는 원뿔 모양의 영역이 발생
					- 광원은 스폿 광원 원뿔의 가장자리로 갈수록 약해짐
					- 플래시라이트, 자동차 헤드라이트 및 서치라이트 같은 인공 광원으로 사용

				3. 방향 광원(Directional Lights)
					- 방향 광원은 씬에서 햇빛 같은 효과를 만드는 데 매우 유용
					- 방향 광원은 **무한한 거리에 멀리 떨어져 있는 광원**이라고 생각
					- 씬의 모든 오브젝트에는 광원이 **항상 같은 방향**에서 오는 것처럼 비춤
					- 광원과 타겟 오브젝트의 거리는 정의되어 있지 않으므로 광원이 약해지지 않음
					- 해나 달을 시뮬레이션할 수 있음
					- 라이팅 창의 Sun 파라미터에 지정된 광원을 회전하면 스카이 박스가 업데이트 됨

				4. 면 광원(Area Lights)
					- 면 광원은 공간에 있는 사각형에 의해 정의됨
					- 광원은 전체 표면 영역에 걸쳐 균등하게 **모든 방향으로 사각형의 한쪽 면에서만 발산**
					- 면 광원의 범위는 **수동으로 제어할 수 없다**
					- 광원에서 멀어질수록 거리의 역제곱으로 광도가 약해짐
					- 조명 연산에는 프로세서 성능이 꽤 많이 사용되므로, 면 광원은 런타임 시점에 사용할 수 없고 **라이트맵으로만 베이크할 수 있음**
					- 면 광원은 오브젝트를 여려 다양한 방향에서 동시에 비추기 때문에 다른 광원 타입에 비해 셰이딩이 더 부드럽고 섬세함
					- 작은 면 광원을 사용하면 실내 조명처럼 더 작은 광원을 점 광원보다 사실적으로 시뮬레이션 가능

				5. 발광 머티리얼(Emissive Lights)
					- 발광 머티리얼은 면 광원처럼 전체 표면 영역에서 빛을 발산
					- **게임플레이 중에** 컬러와 광도 등의 관련 프로퍼티를 변경 가능
					- 면 광원은 미리 계산된 실시간 GI에서 지원되지 않지만, 발광 머티리얼을 사용하여 유사한 부드러운 조명 효과를 실시간으로 구현 가능
					- **Emission은 스탠다드 셰이더의 프로퍼티로**, 이를 통해 씬의 정적 오브젝트에서 광원을 발산
					- 발광 머티리얼의 범위 값은 없지만, 발산된 광원은 다른 머티리얼과 마찬가지로 2차 함수에 비례하여 약해짐
					- 발산된 광원은 인스펙터에서 **정적(Static) 또는 라이트맵 정적(Lightmap Static)으로 표시된 오브젝트만 비춤**
					- 캐릭터처럼 정적이지 않은 **동적인 지오메트리에 적용된 발광 머티리얼은 씬 조명의 강도를 높이지 않음**
					- 

				6. 주변광(Ambiente Light)
					- 씬 전체에 있고 특정 광원 오브젝트에서 나오지 않는 광원
					- 씬의 전체적인 외양과 밝기에 중요하게 기여할 수 있음

		4. 섀도우(Shadows)
			1. 섀도우
				1. 섀도우는 어떻게 작동하나?
			
			2. 방향 광원 섀도우
				1. 방향 광원 섀도우
					- 방향 광원은 일반적으로 햇빛을 시뮬레이션하고, 광원 하나로 씬 전체를 비출 수 있음
					- 따라서 섀도우 맵이 종종 씬의 커다란 부분을 한꺼번에 덮고
					- 이로 인해 섀도우가 원근 앨리어싱이라는 문제에 취약해짐
					- **원근 앨리어싱**은 카메라에 가까이 보이는 섀도우 맵 픽셀이 카메라에서 더 멀리 있는 픽셀에 비해 더 크고 각져보이는 현상
					- 원근 앨리어싱은 섀도우 맵에 부드러운 섀도우와 높은 해상도를 사용하는 경우 완화
					- 하지만 그렇게 되면 그래픽스 하드웨어 리소스가 더 많이 요구되므로 프레임 속도가 감소될 수 있음

				2. 섀도우 캐스케이드
					- 원근 앨리어싱이 발생하는 이유는 섀도우 맵의 여러 다른 영역이 **카메라의 원근에 따라 불균형하게 스케일**되기 때문
					- 절두체 영역을 카메라에서 떨어진 거리에 따라 **두 개의 존으로 나누어** 원근 앨리어싱을 감소시킬 수 있음
					- 이런 섀도우 맵 크기의 단계적 감소를 **Cascaded shadow maps**라고 함
					- Edit -> Project Settings -> Quality 에서 섀도우 캐스케이드를 설정할 수 있음
					- 섀도우 캐스케이드 또한 렌더링에 리소스가 많이 사용되지만 전체 섀도우에 고해상도 맵을 사용하는 것보다는 여전히 적은 리소스가 사용됨

				3. 섀도우 거리(Shadow distance)
					- 오브젝트의 섀도우는 오브젝트가 카메라에서 멀수록 눈에 덜 띔
					- Unity에서는 Edit -> Project Settings -> Quality 의 Shadow Distance 프로퍼티를 사용하여 거리에 따라 섀도우를 조정할 수 있음
					- 카메라에서 설정 거리보다 멀리 떨어져 있는 오브젝트는 섀도우가 전혀 없음
					- 이 거리에 근접하는 오브젝트의 섀도우는 점차적으로 페이드 아웃됨
					- 모바일 플랫폼에서는 섀도우 캐스케이드가 지원되지 않으므로 섀도우 거리를 적절히 사용하여 렌더링 성능을 개선할 수 있음

				4. 섀도우 팬케이킹

			3. 전역 조명
				1. Lightmapping
					1. 전역 조명 개요
						1. 전역 조명
							- 전역 조명(GI)은 직접 표면에 닿는 광원(직접광)뿐만 아니라 다른 표면에 부딪혀 반사되는 광원(간접광)을 모델링하는 시스템
							- 오브젝트는 서로의 형상에 영향을 미치기 때문에 간접 조명을 모델링하면 가상 세계를 더 현실적이고 연결된 것처럼 만들 수 있음

						2. GI 개념
							- 간접 조명 계산에 너무 많은 시간이 걸렸기 때문에 일반적으로 비디오 게임이나 실시간 그래픽스 애플리케이션에는 직접 조명만 사용해왔음
							- 이러한 한계를 극복하기 위해 게임에서는 이동하지 않는 정적인 오브젝트와 표면에 대해 간접광을 미리 계산하는 방법이 고안
							- Unity는 **베이크된 GI**라고 하는 이 기술을 지원함
							- 이 기술의 이름은 간접광이 미리 계산되어 저장(베이크)되는 프로세스인 베이크의 이름을 따서 만들어짐
							- 간접광 외에도 베이크된 GI는 확보된 계산 시간을 활용하여 실시간 기술로는 달성하기 어려운 면 광원이나 간접광에서도 더 사실적이면서 부드러운 그림자를 제작 가능
							- Unity5.0에서는 **미리 계산된 실시간 GI라는 새로운 기술**을 지원
							- 위에서 언급한 베이킹과 비슷하게 사전 계산 단계가 필요
							- 정적인 오브젝트만을 대상으로 함
							- 하지만 단순히 빌드할 때 씬에서 광원이 어떻게 반사되는지 미리 계산하는 것이 아니라 **모든 경우의 광원 반사를 미리 계산**하여 이 정보를 런타임 시점에 사용할 수 있도록 인코딩
							- 미리 계산된 실시간 GI는 부드러운 음영을 만들어내지만 씬이 아주 작지 않은 한, 베이크된 GI로 얻을 수 있는 것보다는 전제적인 조명이 조금 거칠어 질 수 있음
						
						3. GI의 한계
							- 베이크된 GI와 미리 계산된 실시간 GI는 공통적으로 베이크/사전 계산 단계에서 **정적 오브젝트**만을 대상으로 함
							- 움직이는 오브젝트는 다른 오브젝트로 빛을 반사하거나 다른 오브젝트에서 반사되는 빛을 받을 수 없음
							- 하지만 **라이트 프로브**를 사용하면 정적 오브젝트에서 반사되는 광원을 움직이는 오브젝트에 투영할 수 있음

					2. 프로그레시브 라이트매퍼
						1. 프로그레시브 라이트매퍼 개요
							- 고속 경로 추적 기반 라이트매퍼 시스템
							- 짧은 준비 단계를 통해 지오메트리와 인스턴스 업데이트를 처리하고 G버퍼 및 차트 마스크를 생성
							- 결과물을 즉시 생성한 후 점진적으로 다듬기 때문에 인터랙티브 조명 워크플로를 크게 개선 가능
							- 프로그레시브 라이트매퍼는 베이크하는 동안 예상 시간을 제공하여 베이크 시간을 쉽게 예측 가능

						2. 라이트매핑: 시작하기
							- 라이트매핑은 씬의 표면 밝기를 미리 계산하고 계산 결과를 나중에 사용하기 위해 차트 또는 라이트맵에 저장하는 프로세스

						3. 라이트맵 경계 부분 꿰메기
							- 베이크된 라이트맵을 사용하여 렌더링된 게임 오브젝트에서 원치 않는 날카로운 가장자리를 부드럽게 처리하는 기법
							- 프로그레시브 라이트매퍼에서 작동
							- 경계 부분 꿰매기는 **하나의 게임 오브젝트에서만** 적용

						4. UV 오버랩 피드백
							- 각 라이트맵에는 많은 차트(Charts)가 포함
							- 런타임 시점에서 Unity는 이러한 차트를 메시 면에 매핑
							- 그리고 차트의 조명 데이터를 사용하여 최종 형상을 계산
							- GPU 샘플링의 동작 방식 때문에 두 차트가 너무 인접해 있으면 한 차트의 데이터가 다른 차트로 흘러 들어갈 수 있음
							- 이런 경우 대개 의도치 않은 앨리어싱, 픽셀레이션 또는 기타 그래픽 결함이 발생
							- 해결책
								1. Unity가 자동으로 라이트맵 UV를 생성하는 경우 **팩 마진(Pack Margin)**을 높임
								2. 라이트맵 UV를 직접 제공하는 경우 모델링 패키지를 사용하여 마진을 추가
								3. 전체 라이트맵의 해상도를 높임
								4. 단일 게임 오브젝트의 해상도를 높임

						5. 커스텀 폴오프
							- 현실에서 광원은 거리가 멀어질수록 희미해지며, 희미한 광원은 밝은 광원보다 범위가 작음
							- 폴오프(Fall-off)는 광원이 희미해지는 속도를 나타냄
							- Unity의 기본 폴오프 조명 동작과 함께 커스텀 폴오프 설정을 사용 가능
							- 프로그레시브 라이트매퍼는 스크립트를 통해 구혈할 수 있는 커스텀 폴오프 프리셋을 제공

					3. 인라이튼(Enlighten)
						1. Unity에서는 베이크된 전역 조명과 미리 계산된 실시간 전역 조명이라는 두 가지 기법으로 전역 조명과 바운스된 조명을 미리 계산할 수 있음
						2. 인라이튼 조명 시스템은 두 가지 기법에 사용 가능한 솔루션을 모두 제공

				2. 라이트 프로브(Light Probes)
					1. 라이트 프로브 개요
						1. 라이트 프로브를 통해 **씬의 빈 공간을 지나가는 빛에 대한 정보를** 파악해서 사용
						2. 라이트 프로브는 라이트맵과 마찬가지로 베이크된 조명 정보를 씬에 저장
						3. 라이트맵은 씬 표면에 닿는 광원에 대한 조명 정보를 저장
						4. 하지만 라이트 프로브는 **씬의 빈 공간을 지나가는 광원에** 대한 정보를 저장한다는 점이 다름
						5. 라이트 프로브의 일차적인 용도는 씬에서 **움직이는 오브젝트에 고품질 조명을 제공**
						6. 이차적인 용도는 배경에 Unity의 LOD 시스템이 사용될 때 정적 배경에 대한 조명 정보를 제공하는 것

					2. 광원 프로브 배치(Placing Light Probes)
						1. 씬에 라이트 프로브를 배치하려면 Light Probe Group 컴포넌트가 부착된 게임 오브젝트를 사용해야 함

					3. 라이트 프로브 포지션 선택
						1. 라이트 프로브 정보의 해상도는 얼마나 프로브를 빽빽하게 배치했는지에 따라 정의
						2. 게임이 진행되는 동안 수행된 계산 양을 최적화하려면 라이트 프로브를 최소한으로 배치하는 것이 좋음
					
					4. 영역 생성
						1. 게임플레이가 2D평면에서 이루어진다고 하더라도 라이트 프로브는 3차원 영역을 형성해야 함
						2. 이것은 프로브 그룹에 최소 두 개의 수직 레이어 점이 있어야 한다는 의미

					5. 동적 GI를 위한 라이트 프로브 플레이스먼트
						1. Unity의 실시간 GI는 무빙 라이트가 정적 배경에 동적 반사광을 투영할 수 있도록 지원
						2. 하지만 라이트 프로브를 사용 중인 경우 움직이는 게임 오브젝트의 무빙 라이트에서 동적 반사광을 수신할 수도 있음

				3. 움직이는 오브젝트를 위한 라이트 프로브
					1. 실시간 모드 및 혼합 모드 광원이 움직이는 오브젝트에 직접 광원을 캐스트할 수 있음
					2. 따라서 라이트 프로브를 사용하지 않으면 움직이는 오브젝트는 정적인 환경에서 반사광을 받지 않음
					3. 라이트 프로브는 씬에 광원이 반사되는지에 대한 정보를 저장
					4. 그러므로, 오브젝트가 게임 환경에서 공간을 통과하여 움직일 때, 오브젝트는 현재 포지션의 반사광의 근사값을 보여주기 위해 라이트 프로브에 저장된 정보를 사용



---

### 캐릭터 제작
* 스크립트
	- Awake
		1. 스크립트가 실행될 때 한 번만 호출되는 함수
		2. 주로 게임의 상태 값 또는 변수의 초기화에 사용
		3. Start 함수가 호출되기 전에 맨 먼저 호출
		4. 스크립트가 비활성화 되어 있어도 실행
		5. 코루틴 사용불가
	- Start
		1. Update 함수가 호출되기 전에 한 번만 호출
		2. 스크립트가 활성화 되어 있어야 실행
		3. 다른 스크립트의 모든 Awake가 모두 다 실행된 이후에 실행
	- Update
		1. 프레임마다 호출되는 함수로 주로 게임의 핵심 로직을 작성
		2. 스크립트가 활성화 되어 있어야 실행
	- LateUpdate
		1. 모든 Update 함수가 호출되고 나서 한 번씩만 호출
		2. 순차적으로 실행해야 하는 로직에 사용
		3. 카메라 이동 로직에 주로 사용하는 함수
		4. 스크립트가 활성화 되어 있어야 실행
	- FixedUpdate
		1. 주로 물리 엔진을 사용하는 경우에 일정 시간 간격으로 힘을 가할 때 사용하는 함수
		2. 발생하는 주기가 일정
	- OnEnable
		1. 게임오브젝트 또는 스크립트가 활성화 되었을 때 호출
		2. 이벤트 연결 시 사용
		3. 코루틴 사용 불가
	- OnDisable
		1. 게임오브젝트 또는 스크립트가 비활성화 되었을 때 호출
		2. 이벤트 연결을 종료할 때 사용
		3. 코루틴 사용 불가
	
---

### 3. 발사체 제작
* Rigidbody 컴포넌트
	- Rigidbody 컴포넌트를 게임오브젝트에 추가하면 해당 게임오브젝트는 중력의 영향을 즉시 받기 시작
	- Collider 컴포넌트도 하나 이상 추가할 경우 게임 오브젝트가 당하는 충돌에 의해 움직임
	- Rigidbody 컴포넌트는 연결된 게임 오브젝트의 이동을 제어하므로 스크립트에서 포지션과 회전 같은 트랜스폼 프로퍼티를 변경하여 오브젝트를 이동하면 안됨
	- 대신 Forces를 가하여 게임 오브젝트를 밀고 물리 엔진이 결과를 계산하도록 해야 함
	- 게임 오브젝트에 리지드바디를 연결하되, 물리 엔진으로 모션이 제어되는 것을 원치 않는 경우 is Kinematic 프로퍼티를 선택
	- 하지만 성능 오버헤드가 발생하므로 신중해야 함
* Collider 컴포넌트
	- 충돌을 감지하기 위한 컴포넌트

* 충돌감지 조건
	- 충돌을 일으키는 양쪽 오브젝트 모두 Collider 컴포넌트가 있어야 함
	- 두 게임오브젝트 중 움직이는 쪽에는 반드시 Rigidbody 컴포넌트가 있어야 함

* 정적 콜라이더
	- 콜라이더는 있지만 리지드바디는 없는 게임 오브젝트
	- 리지드바디 오브젝트가 다가오면 정적 콜라이더와 충돌하지만 정적 콜라이더는 움직이지 않음

* 리지드바디 콜라이더
	- 일반 비키네마틱 리지드바디와 콜라이더가 있는 게임 오브젝트
	- 리지드바디 콜라이더는 물리 엔진에 의해 완전히 시뮬레이션되며 스크립트로부터 적용되는 충돌과 힘에 반응

* 키네마틱 리지드바디 콜라이더
	- 키네마틱 리지드바디오브젝트는 Transform 컴포넌트를 수정하여 스크립트를 통해 움직일 수 있음
	- 하지만 비키네마틱 리지드바디의 경우와 같은 충돌이나 힘에는 반응하지 않음

---

### 추가항목. 드로우콜(배치)
* 드로우 콜(배치)
	- 오브젝트, 파티클 등 CPU에 의해 연산된 정보를 GPU에 넘겨주어 최종적으로 GPU가 화면에 출력한다
	- 이 때 CPU가 GPU를 호출하는 것을 드로우 콜이라고 한다

* Set Pass Call
	- 머티리얼과 쉐이더에 관련된 것에 대한 배치
	- 아틀라스를 활용하여 여러 오브젝트들을 한개의 머티리얼로 묶어서 Set Pass Call을 감소시켜야 한다

* 아틀라스
	- 오브젝트의 수가 많더라도 같은 텍스처를 사용한다면 드로우콜은 한번만 발생
	- 따라서 하나의 텍스처에 많은 이미지들을 모아서 드로우콜을 감소시킨다
	- 이것을 아틀라스라고 한다
	
* 배칭 
	- 복수의 드로우콜을 하나의 드로우콜로 묶어서 처리하는 작업
	- CPU가 GPU에 랜더링 요청을 할 때 데이터 처리 작업을 한꺼번에 해줘서 GPU의 부담을 줄인다

* 동적 배칭
	- 동일한 머티리얼을 공유하고, 버텍스 개수가 총 300이하의 메쉬만 적용 가능(이외의 조건 존재)
	- 유니티에 의해 자동 적용

* 정적 배칭
	- 동일한 머터리얼을 공유하고, 움직이지 않는 오브젝트에 적용할 수 있는 배칭
	- 적용 효과가 크다
	- 메쉬를 강제적으로 합쳐서 메모리에 부담을 준다

* 리얼타임 쉐도우
	- 리얼타임 쉐도우를 해제