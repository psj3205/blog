---
layout: post
title:  "네트워크 정리"
date:   2018-10-12 19:30:32 +0900
---

### 1.
---


### 2.
---


### 3. 데이터 통신 기초
* 데이터란?
	- 네트워크
		1) 통신 매체로 연결해서 컴퓨터와 컴퓨터끼리 데이터를 주고받는 것
		2) 컴퓨터나 사용자가 가진 리소스를 공유하기 위해 존재
		3) 그래서 이루어지는 것이 데이터 통신

	- 데이터
		1) 무언가에 대한 정보를 컴퓨터상에 표현한 것(파일, 홈페이지 정보 등)
		2) 데이터를 주고 받으면서 리소스 공유가 실현

* 데이터 통신
	- 컴퓨터에서 데이터는 비트라는 단위로 표현

	- 인터페이스
		1) 컴퓨터와 통신매체의 중개를 담당하기 위한 전용기기
		2) 통신매체에 따라 데이터의 표현 방법이 다르다. 일반적인 케이블이라면 전기신호

	- 프로토콜
		1) 데이터를 주고받기 위한 규칙
		2) 데이터를 보내는 쪽과 받는 쪽이 같은 프로토콜을 사용

* 정리
	- 네트워크는 데이터를 주고받는 작업
	- 이 작업을 위한 방법이 데이터 통신
	- 데이터 통신을 하기위해서는 인터페이스와 프로토콜이 필요


---


### 4. 회선 교환과 패킷 교환
* 회선 교환
	- 전화기의 방식과 마찬가지로 교환기를 사용하여 연결 회선을 교체하는 방식
	- 교환기의 회선이 모두 점유되면 더 이상 통신을 할 수 없다
	- 다수의 컴퓨터가 동시에 자유롭게 정보를 송수신하기에는 부적합

* 패킷 교환
	- 송신하고 싶은 데이터를 일괄적으로 보내지 않고 여럿으로 분할하여 송신하는 방식
	- 분할한 데이터를 패킷(Packet)이라고 부른다
	- 큰 데이터를 작게 나누어 송신하므로 패킷 1개를 보내는 시간이 짧다.
	- 그러므로 패킷 1개가 회선을 점유하는 시간이 짧다.
	- 어느 한 수신처의 데이터가 회선을 점유하지 않고 다른 수신처의 데이터와 섞여서 송신된다
	- 다수의 컴퓨터가 회선을 공유 가능
	- 컴퓨터 네트워크는 패킷 교환 방식을 사용

* 정리
	- 데이터 통신에는 회선 교환과 패킷 교환이 존재
	- 회선 교환은 파이프를 교체하는 방식
	- 패킷 교환은 데이터를 패킷으로 분할하여 송신하는 방식
	- 컴퓨터 네트워크는 패킷 교환 방식
	- 동시 통화 수 만큼 회선이 필요했던 전화 회선과는 달리 회선 1개로도 다수 통신 가능


---


### 5. 네트워크의 구조
* 통신에 필요한 기기
	- 컴퓨터 : 데이터를 작성, 송신, 수신
	- 통신 매체
	- 인터페이스
	- 패킷 교환기 : 실제 네트워크에서는 라우터(Router)라는 기기가 패킷 교환기 역할을 함

* Multi Access Network 와 Point to Point Network
	- 패킷 교환없이 케이블 분배기로 연결되는 범위를 세그먼트라고 함
		1) 이 세그먼트 범위 내에 있는 컴퓨터는 패킷교환없이 직접 데이터를 송수신 가능
	- 허브(Hub)라는 기기를 사용하여 세그먼트를 생성
		1) 허브를 사용한 네트워크에서는 컴퓨터가 세그먼트 내의 어떤 컴퓨터로도 자유롭게 데이터 송수신 가능
		2) 이런 네트워크 구조를 Multi Access Network라고 한다
	- Point to Point Network : 컴퓨터 한 대가 다른 한 대의 컴퓨터에만 데이터를 보내는 방식
	- 멀티엑세스 네트워크와 포인트 투 포인트 네트워크를 조합해서 네트워크 전체가 구성

* 정리
	- 패킷 교환 네트워크는 컴퓨터, 통신 매체, 인터페이스, 라우터로 구성
	- 네트워크에는 멀티엑세스 네트워크, 포인트 투 포인트 네트워크 두 종류가 있음
	- 이 두 종류가 조합되어 네트워크 전체가 구성


---


### 6. LAN과 WAN
* 네트워크의 범위
	- 멀티엑세스 네트워크 , 포인트 투 포인트 네트워크는 네트워크를 구조 측면에서 분류한 것
	- 네트워크의 범위나 규모로 네트워크를 분류하는 방식도 존재
	- LAN(Local Area Network) : 가정, 사무실, 빌딩 같은 구내에 설치된 네트워크

* WAN
	- LAN과 다른 지역의 LAN을 연결하기 위해서는 통신매체, 즉 케이블이 연결되어야한다.
	- 하지만 구내를 벗어난 지역에 마음대로 케이블을 연결하는 것은 불법
	- 따라서 통신사업자(KT, SK, LG)가 설치한 통신용 케이블을 이용하여 다른 LAN과 연결
	- 데이터 통신 서비스를 제공하는 통신사업자의 케이블에 데이터를 전송할 권리를 구입해서 네트워크를 구축
	- 이런 네트워크가 WAN(Wide Area Network)

* 정리
	- 자신의 책임으로 좁은 범위에서 만드는 것이 LAN이다
	- 넓은 범위에서 통신사업자로부터 케이블을 빌려서 만들어지는 것이 WAN이다
	- 세계 최대 규모의 WAN은 인터넷이다


---


### 7. OSI 참조 모델(Open Systems Interconnection Reference Model)
* OSI 참조 모델이란?
	- 데이터 통신 전체를 표준화하기 위한 단계 구성도
	- 데이터 통신을 단계로 나누어 각 단계의 순서를 명확히하고 이 모델에 따라 프로토콜을 정의
	- 하지만 표준화는 실패

* OSI 참조 모델
	- 데이터 통신을 7개의 단계로 나눈다

	 +---------------------------------------------------------------------------- -----+
  	| 제7계층 |    응용계층    | 사용자에게 네트워크 서비스를 제공한다     |              |
	  |------------------------------------------------------------------|              |
	  | 제6계층 |    표현계층    | 데이터의 형식을 결정한다                 |   내용표현    |
	  |------------------------------------------------------------------|              |
	  | 제5계층 |    세션계층    | 데이터 송수신의 순서 등을 관리한다        |              |
	  |------------------------------------------------------------------|--------------|
	  | 제4계층 |    전송계층    | 신뢰성이 높은(에러가 적은) 전송을 시행    |              |
	  |------------------------------------------------------------------|     전송물    |
	  | 제3계층 | 네트워크계층  | 전송 규칙과 수신처를 결정한다              |              |
	  |------------------------------------------------------------------|--------------|
	  | 제2계층 |데이터링크계층| 인접기기 사이의 전송을 제어한다             |               |
	  |------------------------------------------------------------------|     전송      |			
	  | 제1계층 |    물리계층   | 전기 기계적인 부분의 전송을 시행한다       |               |
	 +-----------------------------------------------------------------------------------+

	- 송신측에서는 7계층부터 1계층 순서대로
	- 수신측에서는 1계층부터 7계층 순서대로 역할을 수행한다
	- 각 계층은 독립적
	- 다른 계층은 고려할 필요 없음
	- 어떤 계층의 프로토콜 변경은 다른 계층에 영향을 끼치지 않는다
	- 하위 계층은 상위 계층을 위해서 일하고 상위 계층은 하위 계층에 관여하지 않는다

* 정리
	- 데이터 통신은 OSI 참조 모델에 의한 '단계와 순서'로 이해한다
	- OSI 참조 모델은 일곱개의 계층으로 나뉘어 있으며 각각은 독립해 있다
	- 하위 계층은 상위 계층을 위해 일하고 상위 계층은 하위 계층에 대해 관여하지 않는다


---


### 8. 캡슐화
* 순서의 흐름
	- 택배를 예를들어 보자
	- 운반할 물품에 운송에 필요한 것을 덧붙여 함께 운송한다
	- 운반물 + (완충재 + 상자 + 택배 송장)
	- 데이터를 전송할 때도 운반하는 데이터 이외에 다른 것이 필요하다
	- 데이터와 데이터를 보내기 위해 필요한 것들이 통합된 상태를 프로토콜 데이터 유닛(Protocol Data Unit:PDU)라 한다

* 캡슐화
	- OSI 계층을 거칠때마다 필요한 정보를 추가할 수 있다
	- 운반하고 싶은 데이터에 헤더를 추가해 캡술을 만들어 간다

	사용자
	---------------------------------------------------------

	5~7계층                    7계층의 제어 데이터-->데이터
	--------------------------------------------------|------
	                                                  V
	4계층                       4계층의 제어 데이터--> 메시지
	--------------------------------------------------|------  
				                                    		    V
	3계층		      	3계층의 제어 데이터--> 세그먼트, 데이터그램
	------------------------------------------|--------------
							                              V
	2계층         2계층의 제어 데이터--> 데이터그램 <--2계층의 제어 데이터
	------------------------------------------|------------------------
					                                  V
	1계층			           	                  프레임

* 정리
	- 데이터를 송신할 때는 보내고 싶은 데이터 뿐만 아니라 제어용 정보도 필요하다
	- 계층의 순서대로 헤더가 부가되어가는 것을 캡슐화라고 한다
	- 수신한 쪽은 반대의 순서로 헤더를 벗겨서 데이터를 입수한다


     ---


### 9. 프로토콜
* 프로토콜이란?
	- 상위 프로토콜과 하위 프로토콜 간의 데이터를 전송할 수 있는 구조를 인터페이스라고 부른다
	- 앞에서 케이블과 컴퓨터의 중개 역할을 하는 인터페이스와 마찬가지로 프로토콜 간에도 인터페이스라는 용어를 사용한다
	- 프로토콜군 : 상위 하위 프로토콜을 연결하는 인터페이스를 가지고 있는 프로토콜 그룹
	- 데이터 통신은 같은 프로토콜군을 사용하는 컴퓨터나 기기끼리만 가능

* 프로토콜이 결정하는 것
	- 데이터 사용 방법 결정
	- 어떤 헤더를 붙일지 결정
	- 데이터를 송수신하는 순서와 내용을 결정
	- OSI 프로토콜을 대신해 가장 많이 사용되는 것은 TCP/IP 프로토콜군
	- TCP/IP 프로토콜군은 인터넷에서 사용되는 프로토콜이다

* 정리
	- 계층마다 존재하는 프로토콜 그룹을 프로토콜군이라고 한다
	- 프로토콜은 '데이터의 내용을 결정'하고, '헤더를 결정'하고, '송수신 순서를 결정'한다.
	- 사실표준으로써 TCP/IP 프로토콜군이 사용된다


 ---


### 10. TCP/IP 모델
* TCP/IP 모델
	- TCP/IP 모델과 OSI 참조 모델은 전혀 관계가 없음
	- 다만 데이터 통신이라는 관점에서 비슷한 모델

	 +---------------------------------+
  	| 제4계층 |    애플리케이션계층    |
	  |--------------------------------|
	  | 제3계층 |    트랜스포트계층      |
	  |--------------------------------|
	  | 제2계층 |    인터넷계층         |
	  |--------------------------------|
	  | 제1계층 |    인터페이스계층      |
	 +---------------------------------+

* TCP/IP 프로토콜군
	- 애플리케이션계층(제4계층)
		1) HTTP(Hyper Text Transfer Protocol: 홈페이지 열람)
		2) FTP(File Transfer Protocol: 파일전송)
		3) SMTP(Simple Mail Transfer Protocol: 전자메일 송수신)
	- 트랜스포트계층(제3계층)
		1) TCP(Transmission Control Protocol)
		2) UDP(User Datagram Protocol)
	- 인터넷계층(2계층)
		1) IP(Internet Protocol)
		2) ARP(Address Resolution Protocol)
	- 인터페이스계층(1계층)
		1) 이더넷(Ethernet)
		2) 프레임 릴레이(Frame-Relay)
		3) PPP(Point to Point Protocol)

* 정리
	- TCP/IP 모델에서 TCP/IP 프로토콜이 제정되었다
	- TCP/IP 모델은 4개의 계층으로 이루어진다

 ---

### 11. 1계층의 역할과 개요
* 전기 기계적인 전송
  - 케이블이 연결되어 있는 기기에 신호를 전달하는 것이 1계층의 역할

* 통신 매체
  - 신호가 지나는 파이프 역할을 하는 것이 **통신 매체**
  - 케이블에는 전기신호를 사용하는 **동선** 과 광신호를 사용하는 **광파이버** 가 있음
  - 일반적으로 동선케이블(UTP : Unshielded Twist Pair cable)을 사용
  - UTP는 두개가 한쌍인 동선 네 쌍으로 구성(총 8개의 동선)
  - 광파이버는 신호의 안정과 통신속도에서는 우수하지만 선을 굽히기 어려움
  - 반면 동선은 굽히기 쉬워 배선에 유리
  - 네트워크에 사용되는 기기는 사용할 케이블과 케이블에서 사용할 신호에 맞춘 **인터페이스** 가 필요
  - LAN용 케이블에 접속하기 위한 인터페이스로는 **NIC(일명 LAN카드)** 가 일반적

* 정리
  - 1계층의 역할은 케이블이 연결되어 있는 기기에 신호를 전달하는 것
  - 1계층의 역할에 의해 상대에게 데이터가 전달
  - 케이블은 동선 UTP와 광파이버가 존재

---

### 12. 신호와 충돌
* 신호
  - 인터페이스
      1) 컴퓨터와 통신 매체를 중개
      2) **비트를 신호로, 신호를 비트로 변환**
  - 신호에는 아날로그 신호와 디지털 신호가 존재
  - 신호의 형태와 전송방법에 따라 **통신속도** 가 결정
  - 통신속도는 일반적으로 **1초 동안 전해지는 비트 수** 로 표현
  - 단위는 **bps(bit per second)**
  - 통신속도는 **'1초 동안의 신호의 횟수'** 와 **'1회 신호의 비트수'** 로 정해진다
  - 1회 신호의 비트수 : 신호의 크기에 따라 차등을 두어서 신호 한번에 여러비트를 표현

* 신호에 발생하는 문제 3가지
  - 신호의 감쇠
      1) 동선의 저항에 의해 긴 케이블을 지나는 동안 신호가 약해짐
      2) 따라서 약해진 신호의 **진폭을 증폭** 하는 기계를 중간에 설치
  - 노이즈/간섭
      1) 전기 신호가 어떤 윈인에 의해 형태가 무너지는 현상
  - 충돌
      1) 신호가 보내지고 있는 도중에 다른 신호를 보내는 경우 발생
      2) **두 개의 신호가 뒤섞여서 신호의 진폭이 붕괴**
      3) 신호를 보내는 타이밍을 서로 엇갈리게 하여 충돌현상 방지

* 정리
  - 비트를 신호로 바꾸어 케이블에 보냄으로써 상대에게 전달
  - 신호의 형태나 전송 방법에 의해 통신속도가 결정
  - 신호는 감쇠, 노이즈/간섭, 충돌 등의 문제가 발생


---


### 13. 허브
* 허브의 기능
  - 허브에 케이블로 연결되어 있는 기기는 동일 케이블에 연결되어 있는 것과 같은 취급
  - 허브의 첫 번째 기능은 **신호의 증폭과 재생**
  - 허브의 두 번째 기능은 **복수의 기기를 연결해서 네트워크를 구축**
      1) 허브에 연결되어 있는 기기끼리 신호를 주고받을 수 있게 함
  - 허브끼리 연결하여 허브의 포트수 제한을 해소할 수 있다

* 충돌 도메인
  - 허브는 신호를 증폭하고 재생은 하지만 그외의 **수신한 신호에 대해 어떤 제어도 하지 않음**
  - 플러딩(flooding) : 허브는 수신한 포트 이외의 모든 포트에 수신한 신호를 송신
  - 따라서 허브에 연결된 2대 이상의 컴퓨터에서 신호를 동시에 보내면 어딘가에서 신호가 부딪히게 된다
  - 이렇게 충돌이 발생할지도 모르는 범위를 **충돌 도메인** 이라고 한다
  - 허브로 연결되어 있는 컴퓨터는 충돌 도메인 범위 안에 있음

* 정리
  - 허브는 신호의 증폭과 재생을 수행하고 다수의 컴퓨터를 연결
  - 허브는 신호의 증폭과 재생 이외의 제어는 하지 않으며 플러딩을 한다
  - 충돌 도메인은 작아야 한다


---


### 14. 2계층의 역할과 개요
* 2계층의 개요
  - 허브에 연결만 되면 허브내의 모든 컴퓨터에 신호가 전달
  - 보내고 싶은 상대가 특정되어 있다면 어떻게 해야할까?
  - 2계층에서는 신호가 닿는 범위인 세그먼트 내에서의 데이터 전송에 관한 규정을 고려
  - **패킷 교환없이 케이블 분배기로 연결되는 범위가 세그먼트**

* 프레이밍과 신호의 동기
  - **1계층에서 다루는 신호와 케이블 등에 따라 2계층의 규격이 달라진다**
  - 프레이밍 : 1계층에서 주고받은 신호를 비트화해 거기에 의미를 주어 데이터로 취급할 수 있게 한다
  - 데이터 통신 직전에 프리엠블을 보내 데이터를 읽는 타이밍을 맞추는 비동기
  - 데이터를 송신하기 전에 1과 0을 교대로 하는 신호인 프리엠블을 보낸다.
  - 그러면 처음에는 타이밍이 어긋나 있어도 1과 0이 교대로 오는 것을 알고 있으니까 여기에서 타이밍을 맟춘다


---


### 15. 2계층 주소와 이더넷
* 주소와 캐스트
  - 주소 : 데이터를 보내는 상대와 자신을 특정하는 데이터
  - 데이터 전송 방법에 따라 주소의 종류는 3가지가 있다
      1) 유니캐스트 : 1대1 데이터 통신
      2) 브로드캐스트 : 1대 전체 데이터 통신
      3) 멀티캐스트 : 1대 다수(지정된 복수의 기기) 데이터 통신

* MAC 주소
  - 각각의 기기는 유니캐스트 주소를 적어도 한 개 갖고 있음
  - 유니캐스트 주소는 **고유의 값이다(중복x)**
  - 반면 멀티캐스트 주소는 같은 주소를 가진 기기가 여려 개 존재 가능
  - 이더넷에서 사용되는 주소는 **MAC 주소(Media Access Control Address)라고 불리는 주소**
  - 이 주소는 **인터페이스에 지정된 고정 주소** 이다
  - 인터페이스가 고장나서 교체하면 새로운 인터페이스에 할당된 MAC주소로 변한다

* 정리
  - 1대 1인 유니캐스트, 1대 전체인 브로드캐스트, 1대 다수인 멀티캐스트가 있다
  - 기기는 한 개 이상의 유니캐스트 주소를 가진다
  - 이더넷에서는 MAC 주소가 사용


---


### 16. 이더넷
* 이더넷 프레임
  - LAN에서의 2계층은 이더넷이라는 규칙이 적용
  - MAC 주소를 사용해서 누구로부터 어디로를 결정한다
  - 이 주소 정보를 헤더에 붙여서 데이터를 송신
  - 이더넷에서는 **이더넷 헤더와 이더넷 트레일러를 데이터그램에 붙여서** 이더넷 프레임으로 캡슐화한다
  - 이 이더넷 프레임이 신호가 돼서 케이블로 전달
  - 이더넷 프레임
      1) 최소 64바이트 ~ 최대 1,51864바이트
      2) 이더넷 헤더(14바이트) : 수신서 MAC주소 + 송신처 MAC주소 + 타입(페이로드의 내용을 식별)
      3) 페이로드 : 이더넷 헤더와 트레일러에 의해 캡슐화 되는 3계층 PDU
      4) 이더넷 트레일러(4바이트) : FCS(에러를 체크만 한다, 통신중에는 에러를 올바른 값으로 수정할 수는 없다)
  - FCS에서 에러가 발견된 프레임은 파기한다. 그 시점에서 버려지고 파기했다는 것은 송신측에 알리지 않는다

* 이더넷 동작
  - 허브를 사용한 멀티엑세스 네트워크의 경우는 신호, 즉 데이터는 모든 기기에 도달하게 된다
  - 이더넷에서는 수신한 프레임의 수신처 MAC 주소를 보고 자기에게 온 것 외의 다른 프레임을 파기
  - 허브를 사용한 멀티엑세스 네트워크의 경우 신호를 동시에 보내면 도중에서 신호가 충돌해서 읽을 수 없게 될 가능성이 생김
  - 이더넷에서는 **신호를 보내는 타이밍을 겹치지 않도록 비켜나게 함** 으로써 되도록 충돌이 일어나지 않도록 함
  - 이를 위해서 **CSMA/CD라는 액세스 제어** 를 시행

* 정리
	- 이더넷에서는 수신처와 송신처의 MAC 주소, 에러체크 등을 헤더, 트레일러로 붙인다
  - 수신한 프레임의 수신처가 자기가 아닌 경우는 파기
  - 가능한 한 충돌을 막기 위해 CSMA/CD를 사용


---


### 17. 스위치
* 허브와 스위치
  - 충돌 도메인 컴퓨터의 수가 많으면, 송신->충돌->재송신->충돌 같은 일이 일어나서 **효율이 아주 나쁜 상태** 가 된다
  - 충돌이 발생하지 않도록 하기 위한 방법
      1) 신호를 보내는 타이밍이 겹치지 않도록 엇갈리게 하는 방법
      2) **신호가 지나는 길을 나누는 방법** -> 스위치(스위칭 허브)
  - 허브 대신 스위치를 사용
      1) 허브와 마찬가지로 복수의 포트를 가지고 있음
      2) 현재 LAN에서 사용되고 있는 UTP나 광파이버 케이블은 **송신신호** 와 **수신신호** 가 나뉘어 있다.
      3) 따라서 케이블상에서는 자신이 송신한 신호와 상대가 보내 온 신호가 동시에 지나가도 충돌은 발생하지 않는다
  - 충돌은 허브에서 발생
      1) 허브가 동시에 2개 이상의 기기로부터 신호를 수신하면 허브는 그것들을 나누어서 보낼 수 없음. 여기서 충돌이 발생

* MAC 주소 필터링
  - 스위치 안에서 **수신한 프레임을 따로따로 보낼 수 있도록 처리** 해서 충돌을 막는다
  - **MAC 주소 필터링과 버퍼링 2가지 방법이 존재**
  - MAC 주소 필터링
      1) 학습과 스위칭이라는 동작으로 이루어짐
      2) 학습 : 수신한 프레임의 송신처 MAC 주소를 기록
      3) 이것으로 수신한 포트와 MAC 주소를 연관 짓는다
      4) 학습에 의해 스위치는 포트에 연결되어 있는 컴퓨터의 MAC 주소를 기억
  - 이 동작은 MAC 주소에 의해 송신하는 포트를 필터링하기 때문에 MAC 주소 필터링이라 한다
  - 학습전의 MAC 주소 수신의 프레임을 수신한 경우 허브와 마찬가지로 플러딩을 한다

* 정리
  - 충돌은 허브에서 발생
  - 스위치는 MAC 주소 필터링과 버퍼링으로 충돌을 방지
  - 수신처 MAC 주소에 대응한 포트에만 프레임을 송신하는 것이 MAC 주소 필터링


  ---


### 18. 전이중 이더넷
* 버퍼링
  - 스위치는 **MAC 주소 필터링** 으로 **수신처가 다른 프레임이 동시에 스위치에 도달해서 충돌을 일으키지 않게 했다**
  - 수신처가 같은 프레임이 동시에 도달하면 어떻게 되는가?
  - **버퍼링** 으로 충돌 방지
      1) 버퍼(Buffer)를 사용한 처리를 실행
      2) 버퍼는 일시적으로 데이터를 기록해 둘 수 있는 메모리
  - 수신처가 같은 프레임이 동시에 도달할 경우
      1) 그 수신처가 연결되어 있는 포트로부터 데이터를 송신하려고 한다
      2) 하지만 포트는 1개인데 프레임이 2개이므로 이 시점에서 충돌이 발생
      3) 그래서 **충돌할 것 같은 프레임을 버퍼에 일시적으로 저장해둔다**
      4) 한 개는 송신하고 나머지 한 개는 버퍼에 저장
      5) 첫 번째 프레임 송신이 끝나면 저장해 두었던 프레임을 송신
  - 만약 버퍼의 용량이 부족하다면?
      1) **백 프레셔(Back Pressure)** 또는 **IEEE802.3x** 라는 규격을 사용해서 송신을 중단
  - 스위치의 결론적 역할
      1) **충돌 도메인은 기기들에서 충돌 가능성이 있다** 는 범위를 나타냄
      2) 그런데 스위치를 사용하면 충돌이 발생하기 않는다. 즉, **충돌 도메인은 스위치에 의해 분할됨**
      3) 스위치는 충돌 도메인을 축소시켜 데이터 통신 효율을 높인다

* 전이중 이더넷
  - **반이중 통신(Half Duplex)** : 자기가 송신 중일 때는 수신 불가능한 통신 방식
  - CSMA/CD는 반이중 통신
  - **전이중 통신(Full Duplex)** : 동시에 송신과 수신이 가능한 통신 방식
  - 스위치를 사용한 경우에는 충돌 염려가 없으므로 CSMA/CD를 사용할 필요가 없음
  - 따라서 전이중 통신 가능
  - 스위치를 사용해 전이중 통신을 하는 것을 **전이중 이더넷** 이라고 한다

* 정리
  - 버퍼링으로 수신처가 같은 프레임의 충돌을 방지
  - 스위치를 사용함으로써 CSMD/CD를 사용할 필요가 없어서 전이중 이더넷이 가능


---


### 19. 3계층의 역할과 개요
* 네트워크
	- 세그먼트를 넘어선 송수신을 하려면 어떻게 하는가?
	- **패킷 교환기인 라우터를 지나서 다른 세그먼트로 데이터를 보내는 것** 이 3계층의 역할
	- 세그먼트끼리의 데이터 송수신하는 것이 3계층
	- 이제부터 세그먼트는 네트워크라고 부를 것이다

* 인터넷 작업
  - 2계층까지의 기능만으로는 큰 네트워크를 구성 불가능
	- 허브를 사용한 이더넷에서는 송신측이 보낸 신호는 허브의 모든 기기에 도달
	- 스위치를 사용하면 충돌은 없어지지만 브로드캐스트를 제어하지 않는다는 문제는 해결 불가능
	- 브로드캐스트를 송신하면 범위 내의 모든 컴퓨터가 그것을 수신하여 자기와 관계가 있는지 확인하는 작업이 필요
	- 그만큼 컴퓨터의 처리가 증가
	- **라우터를 넘어서는 브로드캐스트는 송신되지 않는다(뒤에 설명)**
	- 1개의 큰 네트워크를 복수의 네트워크로 분할함으로써 브로드캐스트가 도달하는 범위를 제한
	- 전체 기기의 수가 많아져도 각각의 네트워크에만 브로드캐스트가 도달하기 때문에 각 컴퓨터가 처리하는 브로드캐스트의 양은 감소
	- 네트워크 간의 데이터 송수신을 **인터넷 작업** 이라고 한다

* 정리
  - 좁은 의미의 네트워크는 라우터로 나뉘어진 컴퓨터 그룹
	- 네트워크 간의 데이터 통신을 하는 것을 인터넷 작업
	- 3계층에서는 인터넷 작업을 수행


	---


### 20. 인터넷 프로토콜
* 3계층의 역할과 IP
	- 인터넷 작업을 수행하기 위해 필요한 것
		1. 어드레싱
		2. 라우팅

	- 어드레싱	 
		- 3계층에서 사용하는 주소는 **논리주소**
			1. **위치정보** 가 포함(어디의 네트워크에 있는 어느 컴퓨터라는 정보)
			2. 논리주소는 위치 정보를 갖기 때문에 수신처를 찾을 수 있다
		- 2계층의 MAC 주소는 **물리주소**
			1. 위치정보가 포함되어 있지 않음

	- 라우팅 : 수신처까지 어떤 경로로 갈 지를 결정

	- IP(Internet Protocol)
		1. TCP/IP 프로토콜군에서 어드레싱과 라우팅에 의해 인터넷 작업을 수행하기 위한 프로토콜

* 인터넷 프로토콜
	- **TCP/IP에서는 IP를 반드시 사용**

	- IP는 2가지 버전이 존재
		1. **IPv4(우세)**
		2. IPv6

	- 두버전 사이에는 호환성이 없음

* 정리
	- 위치정보를 가진 주소가 논리주소

	- 수신처까지의 경로 선택을 하는 것이 라우팅

	- TCP/IP에서 인터넷 작업을 수행하는 것이 IP


---


### 21. IP주소 1
* IP 주소의 특징
	- 계층형 주소 : 실제 주소와 같이 계층이 존재(성남시 분당구 정자동 ....)
		1. IP와 같은 논리주소의 특징
		2. MAC 주소는 평면형 주소

	- 네트워크 관리자가 컴퓨터에 할당(관리자에 의해 자유롭게 변경가능)
		1. IP 주소는 **네트워크에 접속할 때마다 할당**
		2. MAC 주소는 변경이 불가능

	- MAC 주소와 마찬가지로 **논리 주소에도 유니캐스트, 멀티캐스트, 브로드캐스트 3종류의 주소가 존재**

	- 유니캐스트 주소의 논리 주소중 **네트워크를 표시하는 번호** 는 **접속되어 있는 모든 네트워크** 에서 유일할 필요가 있음

	- 하지만 **컴퓨터 번호** 는 **소속된 네트워크 내** 에서 유일해야 한다. 다른 네트워크에서는 같아도 된다

	- 결론적으로 **네트워크 번호 + 컴퓨터 번호** 는 반드시 유일하다

* IP 주소
	- IP 주소는 IPv4에서 **32비트** (IPv6는 128비트)

	- 8비트마다 10진수로 표기. 8비트 사이에 점을 찍는다

	- 이 8비트 단락이 **옥텟(Octet)**

	- 4개의 옥텟으로 **네트워크 번호의 컴퓨터 번호를 표현**

* 정리
	- IP 주소는 계층형이고 32비트 주소

	- IP 주소는 네트워크 번호와 컴퓨터 번호의 조합

	- 네트워크 번호는 접속되어 있는 모든 네트워크에서 유일해야 하고, 컴퓨터 번호는 그 네트워크 안에서 유일해야 한다

	- 8비트를 1옥텟, 4개의 옥텟은 32비트


---


### 22. IP주소 2
* IP주소의 클래스
 - **ICANN(The Internet Corperation for Assigned Names and Number)** 라는 조직에서 IP주소를 할당
 - ICANN이 IP 주소를 가지고 있다가 기업이나 인터넷 사업자에게 대출해준다
 - 할당된 조직의 규모에 따라 대출 IP주소의 범위를 변경하는데, 그게 **클래스** 이다
 - 클래스는 A~E의 5개 단계로 나뉨  
 	  1. 클래스A는 앞에서부터 8비트가 네트워크 번호 나머지 24비트가 컴퓨터 번호
    2. 클래스B는 앞에서부터 16비트가 네트워크 번호, 나머지 16비트가 컴퓨터 번호
    3. 클래스C는 앞에서부터 24비트가 네트워크 번호, 나머지 8비트가 컴퓨터 번호
 - 네트워크 번호 부분의 비트수가 적으면 그만큼 컴퓨터 번호 부분의 비트수가 많아지게 된다
 - 그만큼 사용할 수 있는 번호가 많아지고 **많은 컴퓨터를 소유하는 네트워크가 될 수 있다**
 - 클래스를 나누어 IP 주소를 할당하는 방식을 **클래스풀 어드레싱** 이라고 한다

* 예약 완료 주소
 - ICANN이 할당하는 것은 **네트워크 번호** 까지이다
 - 컴퓨터 번호는 **호스트 번호** 라고도 한다
 - 호스트 번호는 네트워크의 관리자가 마음대로 정한다
 - 특별한 의미를 지니고 있는 호스트 번호
    1. 호스트 번호의 비트가 모두 0이 되는 주소 : **네트워크 주소**(네트워크 자체를 표시)
		2. 호스트 번호의 비트가 모두 1이 되는 주소 : **브로드캐스트 주소**(네트워크 내의 호스트 모두를 표시)

* 정리
 - IP주소는 규모에 따라 할당되는 범위가 정해져 있으며 그것이 클래스
 - 클래스에 따라 네트워크 번호를 표시하는 부분의 비트수가 정해져있음
 - 호스트 번호의 비트가 모두 0인 주소는 네트워크 주소
 - 호스트 번호의 비트가 모두 1인 주소는 브로드캐스트 주소


---


### 23. 서브네팅
* 네트워크를 분할한다
 - IP를 계층형으로 표현하기 위해 **서브네트워크 또는 서브넷** 라는 분할된 작은 네트워크를 활용
 - 서브넷으로 분할할 때는 서브네트워크를 나타내는 번호인 서브넷 번호가 필요
 - IP 주소는 32비트로 고정되어 있어서 **새롭게 서브넷 번호를 추가하는 것이 불가능**
 - 따라서 호스트 번호의 비트를 **서브넷 번호와 호스트 번호로 분할**

* 서브넷마스크
 - 서브넷은 그 네트워크의 내부에서만 유효
 - 서브넷의 숫자를 크게하면 각 서브넷의 호스트 수는 감소
 - 서브네팅과 관련한 문제가 존재
    1. IP주소의 어디까지가 네트워크 주소인지 모르면 네트워크 구분이 불가능
		2. 물론 클래스를 알면 어디까지가 네트워크 번호인지 알 수 있지만 어디까지가 서브넷 번호인지는 알 수 없음
		3. 그래서 서브넷을 사용할 경우 **서브넷마스크(Subnetmask)** 라고 불리는 비트열을 IP 주소와 동시에 표기
 - 서브넷마스크는 **IP 주소 중에 어디까지가 서브넷 번호인지** 를 나타낸다
 - IP주소와 같은 32비트이고 **네트워크 번호, 서브넷 번호의 비트를 모두 1, 호스트 번호를 0으로 표기**
 - 따라서 서브넷마스크의 비트가 1인 부분이 네트워크 번호

* 정리
 - 네트워크를 작은 서브네트워크로 나눈다
 - 서브네트워크를 사용할 경우 IP 주소는 네트워크 번호, 서브넷 번호, 호스트 번호가 된다
 - 네트워크 번호, 서브넷 번호의 비트수를 나타내기 위해 서브넷마스크를 사용


---


### 24. 클래스리스 어드레싱
* 클래스풀과 클래스리스
 - 23장의 내용은 과거의 방식
 - 현재는 클래스로 IP주소를 할당하지 않음. 클래스풀 어드레싱은 사용되지 않음
 - 인터넷 보급이 활성화되면서 IP 주소를 필요로 하는 조직이 증가
 - IP주소를 좀더 효율적으로 할당하는 **클래스리스 어드레싱(Classless Addressing)** 이 적용

* 클래스리스 어드레싱
 - 클래스라는 구분을 없앤 어드레싱
 - 필요에 따라 네트워크 번호의 비트와 호스트 번호의 비트를 조절한다
 - 클래스리스 어드레싱의 문제점
    1. 클래스가 없기 때문에 어디까지가 네트워크 번호인지 알 수 없음
		2. 클래스풀 어드레싱에서는 이 문제를 서브넷마스크를 이용해 해결
		3. 클래스리스 어드레싱에서는 **프리픽스 길이(Prefix-Length)** 라는 것을 이용
		4. 프리픽스 길이는 네트워크 번호의 길이를 나타내는 값
		5. 예 : 192.168.32.0 / 21 슬래시 뒤에 **네트워크 번호 비트 수(프리픽스 길이)** 를 넣는다

* 정리
  - 클래스풀 어드레싱은 낭비가 많다
	- 클래스를 사용하지 않는 할당 방식이 클래스리스 어드레싱
	- 클래스리스에서는 프리픽스 길이로 네트워크 번호의 비트 수를 표현


---


### 25. DHCP
* 송신처의 IP주소와 MAC 주소
	- 이더넷을 사용해서 IP 데이터그램을 송수신하기 위해서는 4개의 주소가 필요
		1. 수신처의 MAC주소
		2. 송신처의 MAC주소
		3. 수신처의 IP주소
		4. 송신처의 IP주소

	- 송신처의 MAC주소는 송신할 인터페이스의 MAC를 사용

	- 송신처의 IP주소는 송신할 인터페이스에 설정되어 있는 IP주소를 사용
		1. 수동으로 IP 주소를 설정하는 방법 : 네트워크 관리자가 정한 IP주소를 자신의 컴퓨터에 입력
		2. 자동으로 IP 주소가 컴퓨터에 설정 : **DHCP(Dynamic Host Configuration Protocol)**

* DHCP
	- 할당할 IP 주소를 관리

	- 실제로 할당 작업을 수행하는 서버와 할당을 받는 클라이언트로 구성

	- DHCP의 서버를 DHCP서버라고 부름

	- **클라이언트가 IP 주소를 요청하면 서버가 그에 응해 IP 주소를 할당**

	- IP 주소 풀 : 사전에 관리자가 할당할 주소의 범위

	- **서버는 설정된 IP 주소 풀 중에서 요청한 클라이언트에게 각각 유일한 주소를 할당**

	- 네트워크 관리자는 사전에 **IP 주소의 대여 기간** 을 결정

	- DHCP 메시지 : DHCP에서 주고받는 내용

	- DHCP의 동작 : DISCOVER, OFFER, REQUEST, ACK 4종류의 메시지를 클라이언트와 서버 간에 브로드캐스트를 사용해서 주고받는다
		1. 클라이언트는 DHCP DISCOVER 메시지를 브로트캐스트한다
		2. DISCOVER를 받은 서버는 할당할 IP 주소를 풀에서 선택해서 그것을 클라이언트에게 브로드캐스트해서 통지
		3. 클라이언트는 OFFER에서 받은 IP주소로 문제가 없으면 DHCP REQUEST를 서버에 브로드캐스트
		4. REQUEST를 받은 서버는 문제가 없으면 DHCP ACK를 보낸다. 그 때 서브넷마스크 등 옵션 설정도 ACK에 넣어서 같이 보낸다

* 정리
	- 4개의 주소는 데이터를 주고받는 데 필요
	- 송신처 MAC 주소는 송신할 인터페이스에 고정 주소를 사용
	- 송신처 IP 주소 설정 방식은 수동으로 정하는 정적방식, DHCP를 사용하여 자동으로 할당하는 동적 방식이 있다
	- 각 클라이언트는 DHCP 서버가 가지고 있는 어드레스 풀로부터 IP 주소를 할당받음


---


# 26. ARP
* 주소해결 프로토콜(Address Resolution Protocol)
	- 해당 수신처의 IP 주소의 호스트에게 MAC 주소를 질문하는 프로토콜
		1. 사용자 애플리케이션이 수신처 IP 주소를 결정한다
		2. 수신처 IP 주소에 대해 MAC 주소를 질문한다
		3. 그 IP 주소를 가진 컴퓨터는 MAC 주소를 가르쳐준다

* ARP 테이블과 ARP
	- 송신처 컴퓨터는 수신처의 IP 주소를 결정하고, 수신처 MAC 주소를 알기 위해 ARP 테이블을 참조

	- ARP 테이블은 IP 주소와 MAC 주소의 대응표

	- ARP 테이블에 수신처 IP 주소의 대응 MAC 주소가 없는 경우
		1. ARP를 사용해서 수신처에게 MAC 주소를 묻고(ARP 요청: **브로드캐스트** 로 네트워크의 모든 컴퓨터에 송신)
		2. 그 결과를 ARP 테이블에 기재

	- ARP 테이블에 기재되어 있는 IP 주소와 MAC 주소의 대응은 **일정 기간이 지나면 파기**
		1. 인터페이스 고장 등으로 MAC 주소가 변경되어도 대응할 수 있도록 하기 위해

	- 만약 ARP 테이블이 시간 경과로 파기 되지 않을 경우
		1. ARP 주고 받음
		2. ARP 테이블에 수신처 IP에 대응하는 MAC 주소 기재
		3. 수신처의 인터페이스 고장에 의해 MAC 주소 변경
		4. ARP 테이블에서 수신처 MAC 주소를 참조
		5. ARP 테이블의 수신처 MAC 주소와 자신의 MAC 주소가 다르기 때문에 수신하지 않는다

* 정리
	- 수신처 MAC 주소를 알기 위해서는 ARP를 사용
	- IP 주소와 MAC 주소의 대응표인 ARP 테이블을 가진다
	- ARP 테이블은 일정기간 경과 후 파기


---


# 27. DNS
* 수신처 IP 주소를 안다
	- 데이터 통신에 필요한 4개의 주소를 입수하는 마지막 방법
		1. 인터페이스에 고정된 것이 MAC 주소
		2. 수동 또는 DHCP로 입수하는 것이 송신처 IP 주소
		3. ARP로 입수하는 것이 수신처 MAC 주소

	- 마지막으로 수신처 IP 주소를 알아내는 방법
		1. 데이터 전송자가 수신처의 IP 주소를 미리 알고 있는 경우
		2. 도메인 명(Domain name) 사용하는 경우

* DNS
	- 도메인명은 송신할 상대의 컴퓨터 이름을 의미
	- 도메인명은 IP 주소와 마찬가지로 ICANN에서 관리
	- 도메인명으로 송신하고 싶은 상대를 간단하게 기억할 수 있음
	- DNS(Domain Name System)에 의해 도메인명과 IP 주소가 대응
		1. DNS 서버는 이름과 IP 주소의 대응 데이터베이스를 보유
		2. DNS 서버에 문의 해서 수신처의 IP 주소를 입수

	- 데이터 전송을 하기까지의 흐름
		- DHCP, ARP, DNS를 사용하여 4개의 주소를 결정
		1. 자신의 IP 주소는 수동 또는 DHCP에서 할당 받고, MAC 주소는 자동을 안다(인터페이스에 고정이므로)
		2. 사용자 애플리케이션이 수신처의 도메인 명을 결정하면 DNS로 IP 주소를 취득한다
		3. IP 주소가 결정된 후, ARP에 의해 MAC 주소를 취득한다
		4. 이것으로 송신처, 수신처의 MAC 주소, IP 주소를 알았기 때문에 데이터 전송이 가능

* 정리
	- 사용자 혹은 애플리케이션이 수신처를 결정
	- IP 주소를 알고 있으면, 그것을 사용할 수 있음
	- 호스트 명을 알고 있는 경우는 DNS를 사용
	- DNS 서버에 호스트 명에 대응하는 IP 주소를 문의


---


# 28. 주소와 경로
* IP 주소와 MAC 주소
 - 1계층 : 케이블을 통해 신호를 전송
 - 2계층 : 케이블로 연결된 구간의 네트워크 내에서 데이터를 전송
 - 3계층 : 네트워크 간 전송
 - 3계층은 **어드레싱** 과 **라우팅** 으로 인터넷 작업을 수행
 - IP 주소와 MAC 주소의 차이
 	1. 모두 수신처의 주소를 의미하는 것은 동일
	2. MAC 주소는 같은 네트워크 내에서의 수신처를 의미
	3. IP 주소는 최종적인 수신처
- 인터넷 작업에서 데이터는 복수의 네트워크를 경유해서 최종 수신 컴퓨터에 도달
- MAC 주소로 다음으로 보낼 장소를 지정하고 도달하면 다음 도달할 MAC 주소를 지정
- 그에 반해 IP는 최종 수신처의 주소이므로 변경이 없다

* 경로
	- 라우터가 데이터의 이동 경로를 결정
	- 라우터는 자신의 위치에서 다음에 어디로 보낼지만 판단하고 전체 경로는 알지못한다
	- 이러한 방식이 홉 바이 홉(hop by hop)
	- 라우터가 없으면 다른 네트워크에 데이터그램을 보낼 수 없다
		1. 만약 같은 허브에 두 대의 컴퓨터가 연결되어 있는데 서로 다른 네트워크에 소속되어 있다고 가정
		2. 이런 경우, 같은 허브에 있더라도 네트워크가 다르면 데이터그램을 전송할 수 없음
		3. "다른 네트워크에 수신처가 있는 경우에는 라우터로 송신한다"
		4. "같은 네트워크에 수신처가 있는 경우에는 수신처에 직접 송신한다"
		5. 위와 같은 규칙이 작용하여 허브에서 플러딩되지 않음

* 정리
	- IP 주소는 최종 수신처, MAC 주소는 다음 수신처를 결정
	- 라우팅은 다음 수신처를 지정하기 위해 수행하는 홉 바이 홉 방식
	- 라우터가 없으면 다른 네트워크에 데이터그램을 보낼 수 없다
	- 컴퓨터에 설정되어 있는 라우터는 디폴트 게이트웨이라고 부른다


---


# 29. 라우터
* 라우터란
 - 인터넷 작업은 네트워크 간의 데이터 전송
 - 라우터가 없으면 인터넷 작업이 불가능
 - 라우터는 어떤 네트워크의 경계상에 배치되고 다른 네트워크에 데이터그램을 전송하므로
 - **복수의 인터페이스를 가질 수 있다**
 - 라우터의 인터페이스에는 각각 연결되어 네트워크의 IP 주소가 설정
 - 라우터의 각 인터페이스는 각각의 네트워크에 소속
 - 라우터는 네트워크 경계선상에 있기 때문에 복수의 네트워크끼리 연결하는 역할
 - 필터링에 의해 라우팅하는 데이터를 분류 가능

* 라우터의 동작
	- 라우터는 **라우팅 테이블** 을 보유
	- 라우터가 수신한 패킷이 수신처까지 도달하기 위한 최적의 경로가 그려진 지도
	- 라우팅 테이블에서 다음 수신처를 찾아내는 방법 : **최장일치의 룰(Longest Match)**
		1. IP 주소의 비트열과 네트워크 주소의 비트열을 앞에서부터 순서대로 비교해서 가장 많이 일치하는 것부터 선택

* 정리
	- 라우터가 경로 선택을 한다
	- 라우터의 인터페이스는 IP 주소를 갖는다
	- 라우터는 경로를 선택하기 위해서 라우팅 테이블을 갖는다


---


# 30. 디폴트 게이트웨이
* 브로드캐스트 도메인
	- 브로드캐스트는 라우터를 넘어서 전송할 수 없다
	- 브로드캐스트가 도달하는 범위는 브로드캐스트 도메인
	- 라우터는 브로드캐스트 도메인을 나눌 수 있음
	- 충돌 도메인은 스위치가 구분, 브로드캐스트 도메인은 라우터가 구분
	- 브로드캐스트 도메인 = 네트워크

* ARP와 라우터
	- 브로드캐스트는 라우터에서 전송불가
	- 하지만 ARP는 브로트캐스트이다
	- 그렇다면 어떻게 다른 네트워크에 있는 컴퓨터의 MAC 주소를 ARP로부터 알 수 있을까?
	- **디폴트 게이트웨이는 컴퓨터가 다음에 보낼 라우터**
	- 컴퓨터는 다른 네트워크에 데이터그램을 송신할 때 반드시 디폴트 게이트웨이로 송신

* 디폴트 게이트웨이
	- 다른 네트워크로 데이터를 전송하고 싶은 호스트는 **일단 디폴트 게이트웨이로 데이터를 보내서 다른 네트워크로 전송**
	- 즉, 컴퓨터가 **최초로 데이터를 보내는 수신처는 디폴트 게이트웨이**
	- 컴퓨터가 데이터를 송신할 경우 수신처는 반드시 디폴트 게이트웨이의 MAC 주소가 된다
		1. 다른 네트워크에 데이터를 보내는 경우, 호스트는 디폴트 게이트웨이에게 ARP를 수행해서 디폴트 게이트웨이의 MAC 주소를 입수
		2. 호스트는 수신처 MAC 주소를 디폴트 게이트웨이로, 수신처 IP 주소는 수신처 호스트로 해서 패킷을 보낸다
		3. 수신받은 디폴트 게이트웨이는 라우팅을 하고, 중계 라우터, 송신포트를 결정하여 다음에 수신받을 상대(중계라우터 또는 수신처)에게 ARP를 수행
		4. ARP에 의해 입수한 MAC 주소를 수신처 MAC 주소로, 자기자신의 MAC 주소를 송신처 MAC 주소로 갱신하여 송신한다. IP 주소는 변경되지 않음

	- 디폴트 게이트웨이로 ARP를 수행하기 위해 **디폴트 게이트웨이의 IP 주소가 필요** 하므로
	- 컴퓨터에 디폴트 게이트웨이의 IP주소를 수동이나 DHCP로 미리 설정

* 정리
	- 라우터는 브로드캐스트를 다른 네트워크에 보내지 않음
	- 브로드캐스트가 미치는 범위를 브로드캐스트 도메인이라고 한다
	- 컴퓨터는 다른 네트워크로 데이터를 전송하려고 할 경우 디폴트 게이트웨이에 보낸다
	- 그 경우 디폴트 게이트웨이로 ARP를 송신하고, 디폴트 게이트웨이의 MAC 주소를 수신처 MAC 주소로 한다


---


# 31. 라우팅
* 라우팅 테이블
	- 라우팅 테이블에서 수신처 네트워크를 알아내서 다음 라우터를 결정
	- **수신처 네트워크, 중계지점, 메트릭, 수신처의 출구(인터페이스)** 가 기재
	- 수신처 네트워크 주소와 라우팅 테이블을 비교해서 경로를 찾는다(최장일치의 룰)
	- 만약 라우팅 테이블에 수신처 네트워크가 없을 경우에는 수신처 불명으로 데이터그램을 파기

* 2개의 라우팅
	- 최적의 경로를 알기 위해서는 다른 네트워크 경로를 모두 알아야한다
	- 어떻게 다른 네트워크의 모든 경로를 알 수 있을까?
		1. 정적 라우팅
		2. 동적 라우팅
	- 하지만 정적 라우팅을 할 경우 장애가 발생하면 우회로 변경이 자동으로 되지 않는다
	- 그래서 동적 라우팅으로 문제를 해결
		1. 라우터가 자동으로 정보를 서로 교환해서 경로를 알아내는 방법
		2. 모든 경로 중에 자동으로 최적의 경로를 선택해서 라우팅 테이블을 작성
		3. 장애가 발생하면 새로운 최적 경로를 라우팅 테이블에 수정
	- 단점
		1. 라우터끼리 정보를 교환하므로 원하는 데이터 전송 분량이 줄어든다
		2. 서로 교환한 정보를 가지고 최적 경로를 계산해야 하므로 라우터의 처리능력이 필요
		3. 모든 라우터가 동일한 정보를 가져야 한다(**컨버전스 상태** )

* 정리
	- 라우터는 라우팅 테이블을 참조하여 수신처에의 경로를 결정
	- 라우팅 테이블에는 수신처 네트워크, 다음 중계 라우터, 거리, 송신 인터페이스가 기재
	- 라우팅 테이블을 만들기 위해 라우터는 다른 네트워크에의 경로를 알아야 한다
	- 알아내는 방법은 정적 라우팅과 동적 라우팅
	- 컨버전스이여야 한다


---


# 32. 라우팅 프로토콜
* 자율화 시스템
	- 동적 라우팅을 실현하기 위해 라우팅 프로토콜을 사용
	- 라우팅 프로토콜은 근접해 있는 라우터 간의 네트워크 정보를 서로 교환하기 위한 규칙
	- 라우팅 프로토콜의 기능
		1. 정보를 교환
		2. 그에 따라 라우팅 테이블을 변경
	- 자율화 시스템(AS 혹은 경로제어 도메인)
		1. 하나의 관리 단체에 의해 관리되는 네트워크 집합체
		2. 같은 조직이 관리하는 복수의 네트워크를 AS로 통합
	- 라우팅 프로토콜의 종류
		1. AS 간 라우팅용(Exterior Gateway Protocol)
		2. AS 내부 라우팅용(Interior Gateway Protocol)

* 라우팅 프로토콜의 역할
	- 근접해 있는 라우터 간의 네트워크 정보를 서로 교환
	- 정보교환을 언제 할지, 어떻게 할지, 누구에게 할지, 어떤 정보를 전송할지 결정

* 정리
	- 동적 라우팅은 라우팅 프로토콜로 실현
	- 라우팅 프로토콜은 동작 방식과 장소에 따라 여러 종류가 존재
	- 라우팅 프로토콜에 의해 근접해 있는 라우터 간의 네트워크 정보를 서로 교환
	- 라우팅 프로토콜이 언제, 어떻게, 누구에게, 무엇을 보낼지 결정


---


# 33. RIP
* 메트릭
	- 최단 경로가 최적의 경로라고 할 수는 없다
	- **최적의 경로를 결정하는 판단기준을 메트릭** 이라 한다

* RIP
	- 라우팅 프로토콜 중 하나
	- RIP 동작의 핵심은 **거리와 방향**
	- 라우터가 다른 라우터와 교환하는 정보를 RIP에서는 **라우팅 업데이트** 라 부른다
	- 라우팅 테이블을 그대로 교환
	- 이 업데이트를 6번 수신 받지 않으면 그 라우터에는 장애가 발생했다고 간주하고 그 라우터를 사용하는 경로를 파기
	- RIP는 메트릭에서 홉 수를 사용
	- 업데이트를 보내 온 라우터를 그 앞의 네트워크에의 중계 라우터로
	- 업데이트를 받은 인터페이스를 그 앞의 네트워크에의 송신 인터페이스로 결정한다


---


# 34. ICMP
* ICMP(Internet Control Message Protocol)
	- 네트워크의 제어, 관리 등을 수행하는 프로토콜
		1. 호스트A에서 호스트B에 IP 패킷을 송신하고 싶지만, 라우터는 호스트B가 있는 네트워크의 경로를 몰랐다
		2. 라우터는 수신처에 도달할 수 없다는 것을 나타내는 송신 불능 메시지를 ICMP로 호스트A에게 통지

* ICMP의 종류
	- Query 메시지와 Error 메시지

* TTL(Time to Live)
	- IP 해더 항목 중 하나
	- IP 데이터그램의 TTL은 라우터를 경유할 때마다 1만큼씩 줄어들고, 0이되면 그 데이터그램은 파기


---

# 35.


---


# 36. 4계층의 역할과 개요
* 4계층의 역할
	- 1계층은 케이블이 연결되어 있는 상대에 대한 신호 전달
	- 2계층은 신호를 주고받을 수 있는 상태일 때 세그먼트 내에서 어떻게 데이터 송수신 하는지
	- 3계층은 세그먼트 사이에서 어떻게 데이터를 송수신 하는지
	- 4계층 이상의 상위 계층에서는 **전달할, 전달된 데이터에 대해 필요한 처리를 한다**
		1. 데이터 전달은 3계층까지의 역할
		2. 전달하기 전과 전달된 후에 데이터 통신을 위해 필요한 처리를 4계층 이상에서 한다
		3. 데이터 에러 복구
	- 에러복구
		1. 데이터를 수신하면, 송신처에게 확인응답을 한다
		2. 그럼 송신처는 수신처가 데이터를 받을 것을 확인할 수 있다
		3. 만약 에러 발생으로 데이터가 없어지면 수신처는 확인응답을 보낼 수 없다
		4. 데이터를 다시 보냄으로 에러를 복구한다

* 애플리케이션 식별
	- 통신에서 데이터를 주고받는 컴퓨터 소프트웨어를 애플리케이션이라고 한다
	- 실제로 애플리케이션이 데이터를 주고받는다
	- 어느 애플리케이션이 송신한 데이터인지 어느 애플리케이션이 수신한 데이터인지 결정하기 위해 **포트번호** 를 부여
		1. 각 애플리케이션에는 포트번호가 부여되어 각 포트에서 데이터를 주고 받는다

* TCP와 UDP
	- TCP/IP에서 실제로 이런 제어를 수행하는 것이 **TCP** 와 **UDP** 라는 프로토콜이다
	- 이 두개의 프로토콜은 통신할 때 둘 중 어느 한쪽이 사용된다

* 정리
	- 4계층은 신뢰성이 높은 전송을 수행
	- 확인응답, 흐름제어를 수행하고 신뢰성이 높은 데이터 전송을 실시
	- 어느 애플리케이션에 도달할지를 판별하기 위해 포트 번호를 사용
	- 4계층은 TCP와 UDP 두 가지 프로토콜이 있으며, 둘 중 한 개를 사용하여 데이터 전송을 수행


---


# 37. 커넥션과 세그먼트
* 커넥션
	- TCP에서는 애플리케이션 간의 데이터 송수신을 한다
	- 애플리케이션 간의 송수신을 하는 데이터의 길을 **커넥션** 이라고 한다
	- TCP에서 만들어진 통신로는 가상적인 통신로
	- 3계층까지는 컴퓨터와 컴퓨터 간의 데이터 전송
	- 컴퓨터까지는 데이터가 도착하였지만 상대가 존재하지 않을수도 있고 존재하지만 준비가 되지 않을수도 있다
	- 그래서 데이터 전송을 시작하기 전에 미리 확인을 주고받는다
	- 이것이 가상의 통신로를 만든다는 의미로 **커넥션 확립** 이다
	- TCP 헤더의 크기는 기본적으로 20옥텟

* 커넥선의 확립
	- 커넥션을 확립하기 위해서는 상대가 데이터 전송을 허가해야 한다
	- 따라서 통신로 확보를 위해 상대에게 데이터 전송의 허가를 요청
	- 요청받은 상대는 그것에 대한 허가를 송신처에게 알린다
	- 이번에는 반대로 수신처 측이 송신처에게 데이터 전송 허가 요청을 보낸다
	- 마찬가지로 송신처도 데이터 전송 허가를 하면 이로써 쌍방향의 통로가 확보
	- 커넥션의 확립에서는 3번 주고받아야 하기 때문에 3방향(3way)의 악수, **쓰리웨이 핸드쉐이크** 라고 한다
		1. 송신처 -> 수신처 : 커넥션 확립요청
		2. 송신처 <- 수신처 : 커넥션 확립응답+확립요청
		3. 송신처 -> 수친처 : 커넥션 확립응답

* 세그먼트 분할
	- TCP는 애플리케이션으로부터 받은 데이터를 세그먼트로 캡슐화한다
	- 캡슐화 할때 한 개의 데이터를 MSS(Max Segment Size)로 분할하는데 한개의 데이터가 복수의 세그먼트가 된다
	- 각각의 세그먼트에 번호를 부여하고 이것을 시퀀스 번호라고 한다
	- 시퀀스 번호는 세그먼트에 포함되어 있는 데이터의 선두 옥텟에 붙여진 번호

* 정리
	- TCP에서의 데이터 전송에는 커넥션 확립이 필요
	- 커넥션은 가상의 데이터 통로
	- 커넥션 확립은 쓰리웨이 핸드쉐이크 방식으로 수행
	- 큰 데이터는 MSS로 분할해서 전송
	- 전송되는 데이터에는 순서대로 번호가 부여


---


# 38, 윈도우 제어
* 에러 복구
	- TCP에서는 시퀀스 번호를 통해 에러를 복구
	- 세그먼트를 수신하면, 수신한 것을 송신처에게 전달하는데 이것을 확인응답이라고 했다
	- 시퀀스 번호는 보내는 데이터의 앞 부분에 있는 옥텟번호
	- 확인응답 번호는 다음에 받고 싶은 데이터의 선수 옥텟번호
	- 시퀀스 번호로 세그먼트가 보내는 데이터가 전체의 어느 부분에 해당하는지 알 수 있다
	- RTT(round trip time) : 지금까지 보낸 데이터에 대해 확인응답이 돌아오기까지 걸린 시간

* 윈도우 제어
	- 효율을 더 높히기 위해 **복수의 세그먼트전송 -> 확인응답 방식** 을 적용
	- 어떤 일정 수의 세그먼트를 연속해서 보내어 확인응답을 받는다
	- 정확, 확실하게 보내기 위해 TCP는 흐름제어의 하나인 윈도우 제어를 한다
	- 윈도우 제어에서는 일단 수신한 데이터를 일시적으로 보관해 두기 위한 버퍼를 가지고있다
	- TCP에서는 데이터가 넘치는 것을 막아야 데이터 손실을 방지할 수 있다
	- 그래서 상대방에게 자신이 어느 정도 버퍼량을 가지고 있는지를 알려주어야 한다, 이것이 윈도우 사이즈이다
	- 윈도우 사이즈를 상대방에게 알려줌으로써 윈도우사이즈만큼의 데이터를 한번에 보내도 오버플로가 발생하지 않는다
	- 결국 윈도우 사이즈는 확인응답을 기다리지 않고 보낼 수 있는 데이터양

* 정리
	- 확인응답을 보낼 때는 다음에 수신받을 데이터의 번호를 넣는다
	- 전송에러가 발생했을 때에는 지금 보낸 것과 같은 데이터를 보낸다
	- TCP는 윈도우 제어라는 구조로 버퍼 플로를 방지
	- 상대방의 버퍼사이즈=윈도우 사이즈를 확인하면서 송수신을 한다
	- 윈도우 사이즈까지는 확인응답을 수신하지 않아도 한번에 보낼 수 있다


---


# 39. 포트 번호
* 애플리케이션 통신
	- TCP는 쓰리웨이 핸드쉐이크에 의한 커넥션, 에러 복구, 흐름제어 등을 수행
	- 포트 : 데이터를 주고 받기 위해서 애플리케이션에 연결하는 가상의 출입구
	- IP 주소와 MAC 주소만으로는 애플리케이션을 식별할 수 없다(각 컴퓨터까지만 식별가능, 컴퓨터내의 애플리케이션끼를는 식별불가능)
	- 이 포트는 16비트, 즉 65536개가 있다
	- 포트는 애플리케이션과 TCP/IP 통신 기능을 연결하는 길
	- 수신처 포트 번호를 모르면 데이터를 보낼 수 없다
	- 수신 받을 애플리케이션이 포트와 접속해 있지 않으면, 데이터는 도달할 수 없다는 의미
	- 포트 번호 중 1023번 이하는 웰 노운 포트 번호이기 때문에 사용해서는 안된다
	- 1024~49151번까지는 등록된 포트라고 부르는 미리 등록되어 있는 포트 번호이다. 이미 정해진 애플리케이션과 연결되어 있다
	- 송신하는 측의 애플리케이션은 이런 번호 이외의 49152~65535번까지의 번호 중에서 원하는 번호를 선택하여 사용

* 정리
	- 포트 번호로 어느 애플리케이션의 데이터인지 식별
	- 포트와 애플리케이션을 접속하는 기능을 소켓
	- 자주 사용되는 서비스는 웰 노운 포트를 사용
	- 송신처는 49152번 이후의 중복되지 않는 번호를 자유롭게 사용


---


# 40. UDP
* TCP의 단점
	- TCP/IP에서는 4계층에 2개의 프로토콜이 존재
	- TCP와 UDP
	- TCP의 단점
		1. 정확하게 데이터를 전송하기 위한 절차(쓰리웨이 핸드쉐이크, 에러복구, 흐름제어)가 전송효율을 감소할수 있다
		2. 확인응답으로 인해 일정시간을 대기하므로
		3. 그만큼 일정시간동안 보내는 데이터의 양이 감소

* 아무것도 하지 않는 UDP
	- UDP에는 TCP에 있던 시퀀스 번호, 확인응답 번호, 윈도우 사이즈, 제어비트가 없다
	- UDP의 단점은 정확, 확실하지 않다는 점(TCP의 반대)
	- UDP의 장점은 고속이라는 점(이 역시 TCP의 반대)

* UDP의 용도
	- 고속성이나 실시간 송수신이 필요한 애플리케이션(VoIP, 동영상 스트리밍 배포) 등에 사용
	- 브로트캐스트가 필요한 애플리케이션도 UDP를 사용

* TCP와 UDP의 브로드캐스트
	- TCP는 상대를 모르면 송신할 수 없기 때문에 브로드케스트를 할 수 없다(커넥션, 확인응답을 위해 주소를 특정해야 하므로)
	- UDP에서 브로드케스트를 수행할 경우
		1. 송신할 데이터가 1개로 끝나기 때문에 대역의 소비가 적다
		2. 송수신측에서의 버퍼 유지도 필요없다
		3. 상대의 주소를 몰라도 송신할 수 있다


---


# 41. 네트워크 주소 변환
* 사설 IP 주소
	- 인터넷에 연결하지 않는다는 조건으로 자유롭게 사용하는 IP

* 네트워크 주소 변환(Network Address Translation)NAT
	- IP주소 고갈문제 해결 방법중 하나
	- 예
		1. 인터넷에 접속하고 싶은 500대의 컴퓨터가 있는 네트워크가 있다고 가정
		2. 500대의 글로벌 IP를 모두 마련하기는 힘들다, 그래서 16개의 글로벌 IP를 구했다고 가정
		3. 먼저 내부 네트워크에 사설IP주소를 할당(내부 TCP/IP를 사용한 통신을하기 위해)
		4. 그 후에 인터넷을 사용할 컴퓨터에게 사설IP 주소를 글로벌 IP 주소로 변환해준다
	- 단점 : 동시 접속하는 컴퓨터의 수는 글로벌 IP의 수와 같다

* 정리
	- 사설 IP주소로는 인터넷에 접속할 수 없다
	- 글로벌 IP주소는 부족한 상황
	- 사설 IP주소와 글로벌 IP주소를 변환하는 것이 NAT이다
	- 보유한 글로벌 IP주소 이상의 호스트는 동시에 인터넷에 접속할 수 없다


---


# 42. NAPT
* NAPT
	- NAT은 내부 네트워크에서 사용하는 사설IP 주소와 인터넷에서 사용하는 글로벌 IP주소를 변환하는 기술이다
	- 하지만 인터넷을 접속하기 위해서는 글로벌 IP주소와 사설IP주소가 1:1 대응이 되어야 하므로 결국 많은 글로벌IP주소가 필요하다
	- 그래서 NAPT(Network Address Port Translation)가 등장
	- NAPT의 가장 큰 특징은 하나의 글로벌IP 주소로 복수의 컴퓨터를 접속 가능하는 것
	- IP주소뿐만 아니라 포트 번호도 변환해서 복수의 컴퓨터 접속을 가능
		1. NAT와 마찬가지로 IP주소를 변환하지만, IP주소를 변환할 때 포트 번호도 변환하고 그 대응을 NAT 테이블에 기재
		2. 응답의 경우, IP주소와 포트번호를 NAPT 테이블에서 확인하고, IP주소와 포트번호를 변환
	- 포트 번호가 다르므로 한개의 글로벌 IP 주소로 접속하고 있는 복수의 기기를 구별 가능
	- 또다른 장점은 보안
		1. NAPT 테이블에 없는 변환은 변환되지 않기 때문에 내부 네트워크에 흐르지 않음

* 정적 NAPT
	- LAN 내부에서 외부로 공개하고 싶은 서버가 있을경우
	- NAPT 테이블에 존재하는 변환 밖에 할 수 없으므로 외부에서 서버에 접근할 수 없다
	- 그래서 미리 NAPT 테이블에 수동으로 변환시켜 저장한다
	- 이것을 정적 NAPT라고 한다

* NAPT의 단점
	- FTP에서는 데이터 안에도 송신처의 IP주소와 포트 번호가 기술된다
	- 하지만 NAPT는 데이터 부분에 쓰여져 있는 주소는 변환되지 않기 때문에 FTP는 연결되지 않는다


---


# 43. 5~7계층
* 5계층 : 세션계층
	- 5,6,7 계층은 TCP/IP의 경우 통합해서 하나의 프로토콜이 된 경우가 많다
	- HTTP 등은 한 개의 프로토콜로 5,6,7계층의 역할을 수행
	- 애플리케이션 간의 논의 관리가 세션계층의 역할

* 6계층 : 표현계층
	- TCP/IP에는 다양한 애플리케이션이 존재하는데 각각의 목적에 맞는 데이터 형식이 있다
	- 컴퓨터 간의 데이터 형식의 차이를 변환으로 없앤다(예 : 텍스트형식 ASCII와 EBCDIC간의 변환)
	- 6계층에서 변환을 해서 하드웨어랑 OS에 따른 차이를 없앤 데이터 교환
	- 송신측에서는 해당 데이터형식의 내용을 네트워크 전송용 코드로 변환하고 수신측에서는 자신이 사용하는 데이터형식으로 변환

* 7계층 : 응용계층
	- 애플리케이션의 목적에 따라 네트워크 서비스를 제공하는 계층
	- 각각의 목적에 따른 프로토콜이 준비

* 정리
	- TCP/IP에서는 5,6,7 계층은 통합해서 한 개의 프로토콜로 되어있다
	- 5계층은 세션관리를 수행
	- 6계층은 데이터의 변환, 압축, 암호화를 한다
	- 7계층은 사용자 애플리케이션에 네트워크 서비스를 제공
